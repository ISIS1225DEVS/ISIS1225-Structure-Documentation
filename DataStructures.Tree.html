<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Order Map - Árboles &mdash; DISC - Data Structures 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
    <link rel="shortcut icon" href="https://avatars.githubusercontent.com/u/68409575?s=200&v=4"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=d45e8c67"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Priority Queue - Colas de prioridad" href="DataStructures.Priority_queue.html" />
    <link rel="prev" title="Map - Tablas" href="DataStructures.Map.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            DISC - Data Structures
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contenido auxiliar:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="documentation-guide.html">Guía de documentación</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contenido del curso:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="DataStructures.Set.html">Set - Conjunto</a></li>
<li class="toctree-l1"><a class="reference internal" href="DataStructures.List.html">List - Listas</a></li>
<li class="toctree-l1"><a class="reference internal" href="DataStructures.Stack.html">Stack - Pilas</a></li>
<li class="toctree-l1"><a class="reference internal" href="DataStructures.Queue.html">Queue - Colas</a></li>
<li class="toctree-l1"><a class="reference internal" href="DataStructures.Map.html">Map - Tablas</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Order Map - Árboles</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#como-usar-la-documentacion">Como usar la documentación</a></li>
<li class="toctree-l2"><a class="reference internal" href="#elementos">Elementos</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#bst-node-py">bst_node.py</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#new_node"><code class="docutils literal notranslate"><span class="pre">new_node()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#get_value"><code class="docutils literal notranslate"><span class="pre">get_value()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#get_key"><code class="docutils literal notranslate"><span class="pre">get_key()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#implementaciones">Implementaciones</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#binary-search-tree-py">binary_search_tree.py</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#new_map"><code class="docutils literal notranslate"><span class="pre">new_map()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#put"><code class="docutils literal notranslate"><span class="pre">put()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#insert_node"><code class="docutils literal notranslate"><span class="pre">insert_node()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#get"><code class="docutils literal notranslate"><span class="pre">get()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#get_node"><code class="docutils literal notranslate"><span class="pre">get_node()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#remove"><code class="docutils literal notranslate"><span class="pre">remove()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#remove_node"><code class="docutils literal notranslate"><span class="pre">remove_node()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#contains"><code class="docutils literal notranslate"><span class="pre">contains()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#size"><code class="docutils literal notranslate"><span class="pre">size()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#size_tree"><code class="docutils literal notranslate"><span class="pre">size_tree()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#is_empty"><code class="docutils literal notranslate"><span class="pre">is_empty()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#key_set"><code class="docutils literal notranslate"><span class="pre">key_set()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#value_set"><code class="docutils literal notranslate"><span class="pre">value_set()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#get_min"><code class="docutils literal notranslate"><span class="pre">get_min()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#get_min_node"><code class="docutils literal notranslate"><span class="pre">get_min_node()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#get_max"><code class="docutils literal notranslate"><span class="pre">get_max()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#get_max_node"><code class="docutils literal notranslate"><span class="pre">get_max_node()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#delete_min"><code class="docutils literal notranslate"><span class="pre">delete_min()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#delete_min_tree"><code class="docutils literal notranslate"><span class="pre">delete_min_tree()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#delete_max"><code class="docutils literal notranslate"><span class="pre">delete_max()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#delete_max_tree"><code class="docutils literal notranslate"><span class="pre">delete_max_tree()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#floor"><code class="docutils literal notranslate"><span class="pre">floor()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#floor_key"><code class="docutils literal notranslate"><span class="pre">floor_key()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ceiling"><code class="docutils literal notranslate"><span class="pre">ceiling()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ceiling_key"><code class="docutils literal notranslate"><span class="pre">ceiling_key()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#select"><code class="docutils literal notranslate"><span class="pre">select()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#select_key"><code class="docutils literal notranslate"><span class="pre">select_key()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rank"><code class="docutils literal notranslate"><span class="pre">rank()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#rank_keys"><code class="docutils literal notranslate"><span class="pre">rank_keys()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#height"><code class="docutils literal notranslate"><span class="pre">height()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#height_tree"><code class="docutils literal notranslate"><span class="pre">height_tree()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#keys"><code class="docutils literal notranslate"><span class="pre">keys()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#keys_range"><code class="docutils literal notranslate"><span class="pre">keys_range()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#values"><code class="docutils literal notranslate"><span class="pre">values()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#default_compare"><code class="docutils literal notranslate"><span class="pre">default_compare()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#algoritmos-de-recorrido">Algoritmos de recorrido</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-DataStructures.Tree.tree_traversal">tree_traversal.py</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#DataStructures.Tree.tree_traversal.inorder"><code class="docutils literal notranslate"><span class="pre">inorder()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#DataStructures.Tree.tree_traversal.preorder"><code class="docutils literal notranslate"><span class="pre">preorder()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#DataStructures.Tree.tree_traversal.postorder"><code class="docutils literal notranslate"><span class="pre">postorder()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#DataStructures.Tree.tree_traversal.inorder_tree"><code class="docutils literal notranslate"><span class="pre">inorder_tree()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#DataStructures.Tree.tree_traversal.postorder_tree"><code class="docutils literal notranslate"><span class="pre">postorder_tree()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#DataStructures.Tree.tree_traversal.preorder_tree"><code class="docutils literal notranslate"><span class="pre">preorder_tree()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="DataStructures.Priority_queue.html">Priority Queue - Colas de prioridad</a></li>
<li class="toctree-l1"><a class="reference internal" href="DataStructures.Graph.html">Graph - Grafos</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">DISC - Data Structures</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Order Map - Árboles</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="order-map-arboles">
<h1>Order Map - Árboles<a class="headerlink" href="#order-map-arboles" title="Link to this heading"></a></h1>
<section id="como-usar-la-documentacion">
<h2>Como usar la documentación<a class="headerlink" href="#como-usar-la-documentacion" title="Link to this heading"></a></h2>
<p>Para leer la guía de uso de la documentación, por favor diríjase a la sección <a class="reference internal" href="documentation-guide.html#guia-doc"><span class="std std-ref">Guía de documentación</span></a>.</p>
</section>
<section id="elementos">
<h2>Elementos<a class="headerlink" href="#elementos" title="Link to this heading"></a></h2>
<section id="bst-node-py">
<span id="bst-node"></span><h3>bst_node.py<a class="headerlink" href="#bst-node-py" title="Link to this heading"></a></h3>
<p>Estructura que contiene la información a guardar en una <code class="docutils literal notranslate"><span class="pre">nodo</span></code> de un árbol binario</p>
<dl class="py function">
<dt class="sig sig-object py" id="new_node">
<span class="sig-name descname"><span class="pre">new_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#new_node" title="Link to this definition"></a></dt>
<dd><p>Crea una nueva entrada (de tipo <a class="reference internal" href="#bst-node"><span class="std std-ref">bst_node</span></a>) de un árbol binario con una llave y un valor dados.</p>
<p>El nodo es creado con los siguientes atributos:</p>
<ul class="simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">key</span></code>: llave del nodo</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">value</span></code>: valor del nodo</p></li>
<li><p><a class="reference internal" href="#size" title="size"><code class="xref py py-attr docutils literal notranslate"><span class="pre">size</span></code></a>: tamaño del subárbol (inicialmente 1)</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">left</span></code>: hijo izquierdo del nodo (inicialmente <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">right</span></code>: hijo derecho del nodo (inicialmente <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> (<em>any</em>) – llave del nodo</p></li>
<li><p><strong>value</strong> (<em>any</em>) – valor del nodo</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>nodo creado</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#bst-node"><span class="std std-ref">bst_node</span></a></p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># App/logic.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">DataStructures.Tree</span><span class="w"> </span><span class="kn">import</span> <span class="n">bst_node</span> <span class="k">as</span> <span class="n">bn</span>

<span class="c1"># Crea una nueva entrada (nodo) de un árbol binario</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">bn</span><span class="o">.</span><span class="n">new_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;uno&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="c1"># Salida esperada:</span>
<span class="c1"># { &quot;key&quot;: 1, &quot;value&quot;: &quot;uno&quot;, &quot;size&quot;: 1, &quot;left&quot;: None, &quot;right&quot;: None }</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="get_value">
<span class="sig-name descname"><span class="pre">get_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_value" title="Link to this definition"></a></dt>
<dd><p>Obtiene el valor <code class="docutils literal notranslate"><span class="pre">value</span></code> de un nodo recibido.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>my_node</strong> (<a class="reference internal" href="#bst-node"><span class="std std-ref">bst_node</span></a>) – nodo del cual se quiere obtener el valor</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>valor del nodo</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>any</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># App/logic.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">DataStructures.Tree</span><span class="w"> </span><span class="kn">import</span> <span class="n">bst_node</span> <span class="k">as</span> <span class="n">bn</span>

<span class="c1"># Crea una nueva entrada (nodo) de un árbol binario</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">bn</span><span class="o">.</span><span class="n">new_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;uno&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="c1"># Salida esperada:</span>
<span class="c1"># { &quot;key&quot;: 1, &quot;value&quot;: &quot;uno&quot;, &quot;size&quot;: 1, &quot;left&quot;: None, &quot;right&quot;: None }</span>

<span class="c1"># Obtiene el valor del nodo</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">bn</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="c1"># Salida esperada:</span>
<span class="c1"># &quot;uno&quot;</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="get_key">
<span class="sig-name descname"><span class="pre">get_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_node</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_key" title="Link to this definition"></a></dt>
<dd><p>Obtiene la llave <code class="docutils literal notranslate"><span class="pre">key</span></code> de un nodo recibido.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>my_node</strong> (<a class="reference internal" href="#bst-node"><span class="std std-ref">bst_node</span></a>) – nodo del cual se quiere obtener la llave</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>llave del nodo</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>any</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># App/logic.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">DataStructures.Tree</span><span class="w"> </span><span class="kn">import</span> <span class="n">bst_node</span> <span class="k">as</span> <span class="n">bn</span>

<span class="c1"># Crea una nueva entrada (nodo) de un árbol binario</span>
<span class="n">node</span> <span class="o">=</span> <span class="n">bn</span><span class="o">.</span><span class="n">new_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;uno&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="c1"># Salida esperada:</span>
<span class="c1"># { &quot;key&quot;: 1, &quot;value&quot;: &quot;uno&quot;, &quot;size&quot;: 1, &quot;left&quot;: None, &quot;right&quot;: None }</span>

<span class="c1"># Obtiene la llave del nodo</span>
<span class="n">key</span> <span class="o">=</span> <span class="n">bn</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="c1"># Salida esperada:</span>
<span class="c1"># 1</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="implementaciones">
<h2>Implementaciones<a class="headerlink" href="#implementaciones" title="Link to this heading"></a></h2>
<section id="binary-search-tree-py">
<span id="binary-search-tree"></span><h3>binary_search_tree.py<a class="headerlink" href="#binary-search-tree-py" title="Link to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="new_map">
<span class="sig-name descname"><span class="pre">new_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#new_map" title="Link to this definition"></a></dt>
<dd><p>Crea una nueva tabla de simbolos (map) ordenada basada en un árbol binario de búsqueda (BST).</p>
<p>La tabla de simbolos es creada con los siguientes atributos:</p>
<ul class="simple">
<li><p><code class="xref py py-attr docutils literal notranslate"><span class="pre">root</span></code>: raiz del árbol (inicialmente <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>tabla de simbolos creada</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#binary-search-tree"><span class="std std-ref">binary_search_tree</span></a></p>
</dd>
<dt class="field-odd">Example<span class="colon">:</span></dt>
<dd class="field-odd"><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># App/logic.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">DataStructures.Tree</span><span class="w"> </span><span class="kn">import</span> <span class="n">binary_search_tree</span> <span class="k">as</span> <span class="n">bst</span>

<span class="c1"># Crea un arbol vacío</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">new_map</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
<span class="c1"># Salida esperada: { &quot;root&quot;: None }</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="bst-put">
<dt class="sig sig-object py" id="put">
<span class="sig-name descname"><span class="pre">put</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#put" title="Link to this definition"></a></dt>
<dd><p>Agrega un nuevo nodo llave-valor a un árbol binario de búsqueda (BST).
Si la llave ya existe, se actualiza el <code class="docutils literal notranslate"><span class="pre">value</span></code> del nodo.</p>
<p>Esta función llama a la función <a class="reference internal" href="#bst-insert-node"><span class="std std-ref">insert_node</span></a> para agregar el nodo en la posición correcta del árbol de manera recursiva.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>my_bst</strong> (<a class="reference internal" href="#binary-search-tree"><span class="std std-ref">binary_search_tree</span></a>) – árbol binario de búsqueda donde se quiere agregar el nodo</p></li>
<li><p><strong>key</strong> (<em>any</em>) – llave del nodo</p></li>
<li><p><strong>value</strong> (<em>any</em>) – valor del nodo</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>árbol binario de búsqueda actualizado</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#binary-search-tree"><span class="std std-ref">binary_search_tree</span></a></p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># App/logic.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">DataStructures.Tree</span><span class="w"> </span><span class="kn">import</span> <span class="n">binary_search_tree</span> <span class="k">as</span> <span class="n">bst</span>

<span class="c1"># Crea un arbol vacío</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">new_map</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
<span class="c1"># Salida esperada: { &quot;root&quot;: None }</span>

<span class="c1"># Agrega un nuevo nodo al árbol</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;uno&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
<span class="c1"># Salida esperada:</span>
<span class="c1"># {</span>
<span class="c1">#     &quot;root&quot;: {</span>
<span class="c1">#        &quot;key&quot;: 1,</span>
<span class="c1">#        &quot;value&quot;: &quot;uno&quot;,</span>
<span class="c1">#        &quot;size&quot;: 1,</span>
<span class="c1">#        &quot;left&quot;: None,</span>
<span class="c1">#        &quot;right&quot;: None</span>
<span class="c1">#     }</span>
<span class="c1"># }</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">Test Scenarios<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>Agrega un nuevo nodo a un árbol vacío</strong></p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># App/logic.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">DataStructures.Tree</span><span class="w"> </span><span class="kn">import</span> <span class="n">binary_search_tree</span> <span class="k">as</span> <span class="n">bst</span>

<span class="c1"># Crea un arbol vacío</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">new_map</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
<span class="c1"># Salida esperada: { &quot;root&quot;: None }</span>

<span class="c1"># Agrega un nuevo nodo al árbol</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;uno&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
<span class="c1"># Salida esperada:</span>
<span class="c1"># {</span>
<span class="c1">#     &quot;root&quot;: {</span>
<span class="c1">#        &quot;key&quot;: 1,</span>
<span class="c1">#        &quot;value&quot;: &quot;uno&quot;,</span>
<span class="c1">#        &quot;size&quot;: 1,</span>
<span class="c1">#        &quot;left&quot;: None,</span>
<span class="c1">#        &quot;right&quot;: None</span>
<span class="c1">#     }</span>
<span class="c1"># }</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><strong>Agrega un nuevo nodo a un árbol no vacío</strong></p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># App/logic.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">DataStructures.Tree</span><span class="w"> </span><span class="kn">import</span> <span class="n">binary_search_tree</span> <span class="k">as</span> <span class="n">bst</span>

<span class="c1"># Crea un arbol vacío</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">new_map</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
<span class="c1"># Salida esperada: { &quot;root&quot;: None }</span>

<span class="c1"># Agrega un nuevo nodo al árbol</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;dos&quot;</span><span class="p">)</span>

<span class="c1"># Agrega otro nodo al árbol</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;uno&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
<span class="c1"># Salida esperada:</span>
<span class="c1"># {</span>
<span class="c1">#     &quot;root&quot;: {</span>
<span class="c1">#        &quot;key&quot;: 2,</span>
<span class="c1">#        &quot;value&quot;: &quot;dos&quot;,</span>
<span class="c1">#        &quot;size&quot;: 2,</span>
<span class="c1">#        &quot;left&quot;: {</span>
<span class="c1">#           &quot;key&quot;: 1,</span>
<span class="c1">#           &quot;value&quot;: &quot;uno&quot;,</span>
<span class="c1">#           &quot;size&quot;: 1,</span>
<span class="c1">#           &quot;left&quot;: None,</span>
<span class="c1">#           &quot;right&quot;: None</span>
<span class="c1">#        },</span>
<span class="c1">#        &quot;right&quot;: None</span>
<span class="c1">#     }</span>
<span class="c1"># }</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><strong>Agregar un nodo con una llave ya existente</strong></p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># App/logic.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">DataStructures.Tree</span><span class="w"> </span><span class="kn">import</span> <span class="n">binary_search_tree</span> <span class="k">as</span> <span class="n">bst</span>

<span class="c1"># Crea un arbol vacío</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">new_map</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
<span class="c1"># Salida esperada: { &quot;root&quot;: None }</span>

<span class="c1"># Agrega un nuevo nodo al árbol</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;dos&quot;</span><span class="p">)</span>

<span class="c1"># Agrega otro nodo al árbol</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;uno&quot;</span><span class="p">)</span>

<span class="c1"># Agrega otro nodo al árbol con una llave ya existente</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;uno modificado&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
<span class="c1"># Salida esperada:</span>
<span class="c1"># {</span>
<span class="c1">#     &quot;root&quot;: {</span>
<span class="c1">#        &quot;key&quot;: 2,</span>
<span class="c1">#        &quot;value&quot;: &quot;dos&quot;,</span>
<span class="c1">#        &quot;size&quot;: 2,</span>
<span class="c1">#        &quot;left&quot;: {</span>
<span class="c1">#           &quot;key&quot;: 1,</span>
<span class="c1">#           &quot;value&quot;: &quot;uno modificado&quot;,</span>
<span class="c1">#           &quot;size&quot;: 1,</span>
<span class="c1">#           &quot;left&quot;: None,</span>
<span class="c1">#           &quot;right&quot;: None</span>
<span class="c1">#        },</span>
<span class="c1">#        &quot;right&quot;: None</span>
<span class="c1">#     }</span>
<span class="c1"># }</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="bst-insert-node">
<dt class="sig sig-object py" id="insert_node">
<span class="sig-name descname"><span class="pre">insert_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#insert_node" title="Link to this definition"></a></dt>
<dd><p>Inserta un nuevo nodo llave-valor en el árbol binario de búsqueda (BST) de manera recursiva.</p>
<p>Esta función es llamada por la función <a class="reference internal" href="#bst-put"><span class="std std-ref">put</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> (<a class="reference internal" href="#bst-node"><span class="std std-ref">bst_node</span></a>) – raiz del árbol donde se quiere agregar el nodo</p></li>
<li><p><strong>key</strong> (<em>any</em>) – llave del nodo</p></li>
<li><p><strong>value</strong> (<em>any</em>) – valor del nodo</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>raiz del árbol binario de búsqueda actualizado</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#bst-node"><span class="std std-ref">bst_node</span></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="bst-get">
<dt class="sig sig-object py" id="get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get" title="Link to this definition"></a></dt>
<dd><p>Busca un nodo en el árbol binario de búsqueda (BST) y devuelve su valor.</p>
<p>Esta función llama a la función <a class="reference internal" href="#bst-get-node"><span class="std std-ref">get_node</span></a> para buscar el nodo en el árbol de manera recursiva.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>my_bst</strong> (<a class="reference internal" href="#binary-search-tree"><span class="std std-ref">binary_search_tree</span></a>) – árbol binario de búsqueda donde se quiere buscar el nodo</p></li>
<li><p><strong>key</strong> (<em>any</em>) – llave del nodo a buscar</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>valor del nodo encontrado o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no se encuentra</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>any</p>
</dd>
<dt class="field-even">Example<span class="colon">:</span></dt>
<dd class="field-even"><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># App/logic.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">DataStructures.Tree</span><span class="w"> </span><span class="kn">import</span> <span class="n">binary_search_tree</span> <span class="k">as</span> <span class="n">bst</span>

<span class="c1"># Crea un arbol vacío</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">new_map</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
<span class="c1"># Salida esperada: { &quot;root&quot;: None }</span>

<span class="c1"># Agrega un nuevo nodo al árbol</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;uno&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
<span class="c1"># Salida esperada:</span>
<span class="c1"># {</span>
<span class="c1">#     &quot;root&quot;: {</span>
<span class="c1">#        &quot;key&quot;: 1,</span>
<span class="c1">#        &quot;value&quot;: &quot;uno&quot;,</span>
<span class="c1">#        &quot;size&quot;: 1,</span>
<span class="c1">#        &quot;left&quot;: None,</span>
<span class="c1">#        &quot;right&quot;: None</span>
<span class="c1">#     }</span>
<span class="c1"># }</span>
</pre></div>
</div>
</dd>
<dt class="field-odd">Test Scenarios<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>Busca un nodo en un árbol vacío</strong></p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># App/logic.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">DataStructures.Tree</span><span class="w"> </span><span class="kn">import</span> <span class="n">binary_search_tree</span> <span class="k">as</span> <span class="n">bst</span>

<span class="c1"># Crea un arbol vacío</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">new_map</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
<span class="c1"># Salida esperada: { &quot;root&quot;: None }</span>

<span class="c1"># Busca un nodo en el árbol vacío</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="c1"># Salida esperada: None</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><strong>Busca un nodo en un árbol no vacío - llave existente</strong></p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># App/logic.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">DataStructures.Tree</span><span class="w"> </span><span class="kn">import</span> <span class="n">binary_search_tree</span> <span class="k">as</span> <span class="n">bst</span>

<span class="c1"># Crea un arbol vacío</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">new_map</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
<span class="c1"># Salida esperada: { &quot;root&quot;: None }</span>

<span class="c1"># Agrega un nuevo nodo al árbol</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;dos&quot;</span><span class="p">)</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;uno&quot;</span><span class="p">)</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;tres&quot;</span><span class="p">)</span>

<span class="c1"># Busca un nodo en el árbol no vacío</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="c1"># Salida esperada: &quot;dos&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p><strong>Busca un nodo en un árbol no vacío - llave no existente</strong></p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># App/logic.py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">DataStructures.Tree</span><span class="w"> </span><span class="kn">import</span> <span class="n">binary_search_tree</span> <span class="k">as</span> <span class="n">bst</span>

<span class="c1"># Crea un arbol vacío</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">new_map</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
<span class="c1"># Salida esperada: { &quot;root&quot;: None }</span>

<span class="c1"># Agrega un nuevo nodo al árbol</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;dos&quot;</span><span class="p">)</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;uno&quot;</span><span class="p">)</span>
<span class="nb">map</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;tres&quot;</span><span class="p">)</span>

<span class="c1"># Busca un nodo en el árbol no vacío</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">bst</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="c1"># Salida esperada: None</span>
<span class="c1"># (No existe el nodo con llave 4)</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="bst-get-node">
<dt class="sig sig-object py" id="get_node">
<span class="sig-name descname"><span class="pre">get_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_node" title="Link to this definition"></a></dt>
<dd><p>Busca un nodo en el árbol binario de búsqueda (BST) de manera recursiva.</p>
<p>Esta función es llamada por la función <a class="reference internal" href="#bst-get"><span class="std std-ref">get</span></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> (<a class="reference internal" href="#bst-node"><span class="std std-ref">bst_node</span></a>) – raiz del árbol donde se quiere buscar el nodo</p></li>
<li><p><strong>key</strong> (<em>any</em>) – llave del nodo a buscar</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>nodo encontrado o <code class="docutils literal notranslate"><span class="pre">None</span></code> si no se encuentra</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#bst-node"><span class="std std-ref">bst_node</span></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="remove">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#remove" title="Link to this definition"></a></dt>
<dd><p>Elimina la pareja llave-valor que coincida con``key``.</p>
<p>Usa la función <code class="docutils literal notranslate"><span class="pre">remove_node()</span></code> para eliminar la pareja</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – El arbol de búsqueda</p></li>
<li><p><strong>key</strong> (<em>any</em>) – La llave asociada a la pareja a eliminar</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>El arbol sin la pareja key-value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>binary_search_tree</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="remove_node">
<span class="sig-name descname"><span class="pre">remove_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#remove_node" title="Link to this definition"></a></dt>
<dd><p>Elimina la pareja llave-valor que coincida con``key``.</p>
<p>Es usada en la función <code class="docutils literal notranslate"><span class="pre">remove()</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> (<em>bst_node</em>) – La raiz del arbol a examinar</p></li>
<li><p><strong>key</strong> (<em>any</em>) – La llave asociada a la pareja a eliminar</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>El arbol sin la pareja key-value</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bst_node</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="contains">
<span class="sig-name descname"><span class="pre">contains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#contains" title="Link to this definition"></a></dt>
<dd><p>Informa si la llave key se encuentra en la tabla de hash.</p>
<p>Usa la función <code class="docutils literal notranslate"><span class="pre">get()</span></code> para buscar la llave en el arbol</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – El arbol de búsqueda</p></li>
<li><p><strong>key</strong> (<em>any</em>) – La llave a buscar</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> si la llave está presente, <code class="docutils literal notranslate"><span class="pre">False</span></code> en caso contrario</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="size">
<span class="sig-name descname"><span class="pre">size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#size" title="Link to this definition"></a></dt>
<dd><p>Retorna el número de entradas en la tabla de simbolos</p>
<p>Usa la función <code class="docutils literal notranslate"><span class="pre">size_tree()</span></code> para contar el número de elementos</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – El arbol de búsqueda</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>El número de elementos en la tabla</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="size_tree">
<span class="sig-name descname"><span class="pre">size_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#size_tree" title="Link to this definition"></a></dt>
<dd><p>Retornar el número de entradas en la a partir del nodo root</p>
<p>Es usada en la función <code class="docutils literal notranslate"><span class="pre">size()</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>root</strong> (<em>bst_node</em>) – La raiz del arbol a examinar</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>El número de elementos en la tabla</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="is_empty">
<span class="sig-name descname"><span class="pre">is_empty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#is_empty" title="Link to this definition"></a></dt>
<dd><p>Informa si la tabla de simbolos se encuentra vacia.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – El arbol de búsqueda</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> si la tabla es vacía, <code class="docutils literal notranslate"><span class="pre">False</span></code> en caso contrario</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="key_set">
<span class="sig-name descname"><span class="pre">key_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#key_set" title="Link to this definition"></a></dt>
<dd><p>Retorna una lista con todas las llaves de la tabla.</p>
<p>Usa la función <code class="docutils literal notranslate"><span class="pre">key_set_tree()</span></code> para construir la lista de llaves</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – El arbol de búsqueda</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Una lista con todas las llaves de la tabla</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>single_linked_list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="value_set">
<span class="sig-name descname"><span class="pre">value_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#value_set" title="Link to this definition"></a></dt>
<dd><p>Retorna una lista con los valores de la tabla.</p>
<p>Usa la función <code class="docutils literal notranslate"><span class="pre">value_set_tree()</span></code> para construir la lista de valores</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – El arbol de búsqueda</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Una lista con todos los valores de la tabla</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>single_linked_list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="get_min">
<span class="sig-name descname"><span class="pre">get_min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_min" title="Link to this definition"></a></dt>
<dd><p>Retorna la llave mas pequeña de la tabla de simbolos</p>
<p>Usa la función <code class="docutils literal notranslate"><span class="pre">get_min_node()</span></code> para encontrar la llave más a la izquierda</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – El arbol de búsqueda</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>La llave más a la izquierda</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="get_min_node">
<span class="sig-name descname"><span class="pre">get_min_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_min_node" title="Link to this definition"></a></dt>
<dd><p>Retorna la llave mas pequeña de la tabla de simbolos</p>
<p>Es usada en la función <code class="docutils literal notranslate"><span class="pre">get_min()</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>root</strong> (<em>bst_node</em>) – La raiz del arbol a examinar</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>La llave más a la izquierda</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="get_max">
<span class="sig-name descname"><span class="pre">get_max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_max" title="Link to this definition"></a></dt>
<dd><p>Retorna la llave mas grande de la tabla de simbolos</p>
<p>Usa la función <code class="docutils literal notranslate"><span class="pre">get_max_node()</span></code> para encontrar la llave más grande de del arbol</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – El arbol de búsqueda</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>La llave más a la derecha</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="get_max_node">
<span class="sig-name descname"><span class="pre">get_max_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_max_node" title="Link to this definition"></a></dt>
<dd><p>Retorna la llave mas grande de la tabla de simbolos</p>
<p>Es usada en la función <code class="docutils literal notranslate"><span class="pre">get_max()</span></code>
Usa la función <code class="docutils literal notranslate"><span class="pre">get_max_node()</span></code> para encontrar la llave más grande</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>root</strong> (<em>bst_node</em>) – La raiz del arbol a examinar</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>La llave más a la derecha</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="delete_min">
<span class="sig-name descname"><span class="pre">delete_min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#delete_min" title="Link to this definition"></a></dt>
<dd><p>Encuentra y remueve la llave mas pequeña de la tabla de simbolos y su valor asociado.</p>
<p>Usa la función <code class="docutils literal notranslate"><span class="pre">delete_min_tree()</span></code> para eliminar la llave más pequeña</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – El arbol de búsqueda</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>El arbol de búsqueda sin la llave más pequeña</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>binary_search_tree</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="delete_min_tree">
<span class="sig-name descname"><span class="pre">delete_min_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#delete_min_tree" title="Link to this definition"></a></dt>
<dd><p>Encuentra y remueve la llave mas pequeña de la tabla de simbolos y su valor asociado</p>
<p>Es usada en la función <code class="docutils literal notranslate"><span class="pre">delete_min()</span></code>
Usa la función <code class="docutils literal notranslate"><span class="pre">delete_min_tree()</span></code> para eliminar la llave más pequeña</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>root</strong> (<em>bst_node</em>) – La raiz del arbol a examinar</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Retorna la raiz del arbol sin la llave más pequeña</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bst_node</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="delete_max">
<span class="sig-name descname"><span class="pre">delete_max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#delete_max" title="Link to this definition"></a></dt>
<dd><p>Encuentra y remueve la llave mas grande de la tabla de simbolos y su valor asociado.</p>
<p>Usa la función <code class="docutils literal notranslate"><span class="pre">delete_max_tree()</span></code> para eliminar la llave más grande</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – El arbol de búsqueda</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>El arbol de búsqueda sin la llave más grande</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>binary_search_tree</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="delete_max_tree">
<span class="sig-name descname"><span class="pre">delete_max_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#delete_max_tree" title="Link to this definition"></a></dt>
<dd><p>Encuentra y remueve la llave mas grande de la tabla de simbolos y su valor asociado.</p>
<p>Es usada en la función <code class="docutils literal notranslate"><span class="pre">delete_max()</span></code>
Usa la función <code class="docutils literal notranslate"><span class="pre">delete_max_tree()</span></code> para eliminar la llave más grande</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>root</strong> (<em>bst_node</em>) – La raiz del arbol a examinar</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Retorna la raiz del arbol sin la llave más grande</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bst_node</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="floor">
<span class="sig-name descname"><span class="pre">floor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#floor" title="Link to this definition"></a></dt>
<dd><p>Retorna la llave que precede a la llave key en la tabla de simbolos.</p>
<p>Si la llave existe, retorna la misma llave. Si no existe, retorna la llave predecedente más cercana como si la llave key existiera en la tabla.
Por ejemplo, si la tabla contiene las llaves [1, 3, 5, 7, 9] y se busca la llave 6, la función retornará 5.</p>
<p>Usa la función <code class="docutils literal notranslate"><span class="pre">floor_key()</span></code> para encontrar la llave predecesora a key</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – El arbol de búsqueda</p></li>
<li><p><strong>key</strong> (<em>any</em>) – La llave de búsqueda</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>La llave predecesora a key</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="floor_key">
<span class="sig-name descname"><span class="pre">floor_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#floor_key" title="Link to this definition"></a></dt>
<dd><p>Retorna la llave que precede a la llave key en la tabla de simbolos.</p>
<p>Si la llave existe, retorna la misma llave. Si no existe, retorna la llave predecedente más cercana como si la llave key existiera en la tabla.</p>
<p>Es usada en la función <code class="docutils literal notranslate"><span class="pre">floor()</span></code>
Usa la función <code class="docutils literal notranslate"><span class="pre">floor_key()</span></code> para encontrar la llave predecesora a key</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> (<em>bst_node</em>) – La raiz del arbol a examinar</p></li>
<li><p><strong>key</strong> (<em>any</em>) – La llave de búsqueda</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>La llave predecesora a key</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ceiling">
<span class="sig-name descname"><span class="pre">ceiling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ceiling" title="Link to this definition"></a></dt>
<dd><p>Retorna la llave que sucede a la llave key en la tabla de simbolos.</p>
<p>Si la llave existe, retorna la misma llave. Si no existe, retorna la llave sucesora más cercana como si la llave key existiera en la tabla.
Por ejemplo, si la tabla contiene las llaves [1, 3, 5, 7, 9] y se busca la llave 6, la función retornará 7.</p>
<p>Usa la función <code class="docutils literal notranslate"><span class="pre">ceiling_key()</span></code> para encontrar la llave sucesora a key</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – El arbol de búsqueda</p></li>
<li><p><strong>key</strong> (<em>any</em>) – La llave de búsqueda</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>La llave sucesora a key</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="ceiling_key">
<span class="sig-name descname"><span class="pre">ceiling_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ceiling_key" title="Link to this definition"></a></dt>
<dd><p>Retorna la llave que sucede a la llave key en la tabla de simbolos.</p>
<p>Si la llave existe, retorna la misma llave. Si no existe, retorna la llave sucesora más cercana como si la llave key existiera en la tabla.
Por ejemplo, si la tabla contiene las llaves [1, 3, 5, 7, 9] y se busca la llave 6, la función retornará 7.</p>
<p>Es usada en la función <code class="docutils literal notranslate"><span class="pre">ceiling()</span></code>
Usa la función <code class="docutils literal notranslate"><span class="pre">ceiling_key()</span></code> para encontrar la llave sucesora a key</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> (<em>bst_node</em>) – La raiz del arbol a examinar</p></li>
<li><p><strong>key</strong> (<em>any</em>) – La llave de búsqueda</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>La llave sucesora a key</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="select">
<span class="sig-name descname"><span class="pre">select</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#select" title="Link to this definition"></a></dt>
<dd><p>Retorna la siguiente llave a la k-esima llave de izquierda a derecha de la tabla de simbolos.</p>
<p>Usa la función <code class="docutils literal notranslate"><span class="pre">select_key()</span></code> para encontrar la llave en la posición pos</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – El arbol de búsqueda</p></li>
<li><p><strong>pos</strong> (<em>int</em>) – la pos-esima llave de izquierda a derecha</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>La llave en la posición pos</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>any</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="select_key">
<span class="sig-name descname"><span class="pre">select_key</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#select_key" title="Link to this definition"></a></dt>
<dd><p>Retorna la siguiente llave a la k-esima llave de izquierda a derecha de la tabla de simbolos.</p>
<p>Es usada en la función <code class="docutils literal notranslate"><span class="pre">select()</span></code>
Usa la función <code class="docutils literal notranslate"><span class="pre">select_key()</span></code> para encontrar la llave en la posición pos</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> (<em>bst_node</em>) – La raiz del arbol a examinar</p></li>
<li><p><strong>key</strong> (<em>int</em>) – la llave de búsqueda</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>La llave en la posición pos</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bst_node</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rank">
<span class="sig-name descname"><span class="pre">rank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rank" title="Link to this definition"></a></dt>
<dd><p>Retorna el número de llaves en la tabla que son estrictamente predecesoras a key
Por ejemplo, si la tabla contiene las llaves [1, 3, 5, 7, 9] y se busca la llave 6, la función retornará 3.</p>
<p>Usa la función <code class="docutils literal notranslate"><span class="pre">rank_keys()</span></code> para encontrar el número de llaves predecesoras a key</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – El arbol de búsqueda</p></li>
<li><p><strong>key</strong> (<em>any</em>) – la llave de busqueda</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>El número de llaves</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="rank_keys">
<span class="sig-name descname"><span class="pre">rank_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rank_keys" title="Link to this definition"></a></dt>
<dd><p>Retorna el número de llaves en la tabla que son estrictamente predecesoras a key
Por ejemplo, si la tabla contiene las llaves [1, 3, 5, 7, 9] y se busca la llave 6, la función retornará 3.</p>
<p>Es usada en la función <code class="docutils literal notranslate"><span class="pre">rank()</span></code>
Usa la función <code class="docutils literal notranslate"><span class="pre">rank_keys()</span></code> para encontrar el número de llaves predecesoras a key</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> (<em>bst_node</em>) – La raiz del arbol a examinar</p></li>
<li><p><strong>key</strong> (<em>any</em>) – la llave de busqueda</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>El número de llaves</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="height">
<span class="sig-name descname"><span class="pre">height</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#height" title="Link to this definition"></a></dt>
<dd><p>Retorna la altura del arbol de busqueda</p>
<p>Usa la función <code class="docutils literal notranslate"><span class="pre">height_tree()</span></code> para encontrar la altura del arbol</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – El arbol de búsqueda</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>La altura del arbol</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="height_tree">
<span class="sig-name descname"><span class="pre">height_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#height_tree" title="Link to this definition"></a></dt>
<dd><p>Retorna la altura del arbol de busqueda</p>
<p>Es usada en la función <code class="docutils literal notranslate"><span class="pre">height()</span></code>
Usa la función <code class="docutils literal notranslate"><span class="pre">height_tree()</span></code> para encontrar la altura del arbol</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>root</strong> (<em>bst_node</em>) – La raiz del arbol a examinar</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>La altura del arbol</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_final</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#keys" title="Link to this definition"></a></dt>
<dd><p>Retorna todas las llaves del arbol que se encuentren entre [key_initial, key_final].</p>
<p>Usa la función <code class="docutils literal notranslate"><span class="pre">keys_range()</span></code> para encontrar las llaves en el rango especificado</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – La tabla de simbolos</p></li>
<li><p><strong>key_initial</strong> (<em>any</em>) – limite inferior</p></li>
<li><p><strong>key_final</strong> (<em>any</em>) – limite superior</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Las llaves en el rago especificado</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>single_linked_list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="keys_range">
<span class="sig-name descname"><span class="pre">keys_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_final</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list_key</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#keys_range" title="Link to this definition"></a></dt>
<dd><p>Retorna todas las llaves del arbol que se encuentren entre [key_initial, key_final].</p>
<p>Es usada en la función <code class="docutils literal notranslate"><span class="pre">keys()</span></code>
Usa la función <code class="docutils literal notranslate"><span class="pre">keys_range()</span></code> para encontrar las llaves en el rango especificado</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> (<em>bst_node</em>) – La raiz del arbol a examinar</p></li>
<li><p><strong>key_initial</strong> (<em>any</em>) – limite inferior</p></li>
<li><p><strong>key_final</strong> (<em>any</em>) – limite superior</p></li>
<li><p><strong>list_key</strong> (<em>single_linked_list</em>) – La lista de respuesta</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Las llaves en el rago especificado</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>single_linked_list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="values">
<span class="sig-name descname"><span class="pre">values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_bst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_initial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_final</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#values" title="Link to this definition"></a></dt>
<dd><p>Retorna todas los valores del arbol que se encuentren entre [key_initial, key_final]</p>
<p>Usa la función <code class="docutils literal notranslate"><span class="pre">values_range()</span></code> para encontrar los valores en el rango especificado</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>my_bst</strong> (<em>binary_search_tree</em>) – La tabla de simbolos</p></li>
<li><p><strong>key_initial</strong> (<em>any</em>) – limite inferior</p></li>
<li><p><strong>key_final</strong> (<em>any</em>) – limite superior</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Las llaves en el rago especificado</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>single_linked_list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="default_compare">
<span class="sig-name descname"><span class="pre">default_compare</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">element</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#default_compare" title="Link to this definition"></a></dt>
<dd><p>Función de comparación por defecto. Compara una llave con la llave de un elemento llave-valor.</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>key</strong> (<em>any</em>) – Llave a comparar</p></li>
<li><p><strong>element</strong> (<em>bst_node</em>) – <code class="docutils literal notranslate"><span class="pre">entry</span></code> a comparar</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>0</strong> si son iguales, <strong>1</strong> si <code class="docutils literal notranslate"><span class="pre">key</span></code> &gt; la llave del <code class="docutils literal notranslate"><span class="pre">element</span></code>, <strong>-1</strong> si <code class="docutils literal notranslate"><span class="pre">key</span></code> &lt; que la llave del  <code class="docutils literal notranslate"><span class="pre">element</span></code></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
<dt class="field-even">Code<span class="colon">:</span></dt>
<dd class="field-even"><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">DataStructures.Tree</span><span class="w"> </span><span class="kn">import</span> <span class="n">bst_node</span> <span class="k">as</span> <span class="n">bst_node</span>

<span class="k">def</span><span class="w"> </span><span class="nf">default_compare</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
   <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">bst_node</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
      <span class="k">return</span> <span class="mi">0</span>
   <span class="k">elif</span> <span class="n">key</span> <span class="o">&gt;</span> <span class="n">bst_node</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
      <span class="k">return</span> <span class="mi">1</span>
   <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="algoritmos-de-recorrido">
<h2>Algoritmos de recorrido<a class="headerlink" href="#algoritmos-de-recorrido" title="Link to this heading"></a></h2>
<section id="module-DataStructures.Tree.tree_traversal">
<span id="tree-traversal-py"></span><h3>tree_traversal.py<a class="headerlink" href="#module-DataStructures.Tree.tree_traversal" title="Link to this heading"></a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="DataStructures.Tree.tree_traversal.inorder">
<span class="sig-name descname"><span class="pre">inorder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_order_map</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DataStructures.Tree.tree_traversal.inorder" title="Link to this definition"></a></dt>
<dd><p>Implementa un recorrido inorder de un arbol binario (tanto AVL como BST). El recorrido pasa por los nodos en el siguiente orden: izquierda, raiz, derecha.</p>
<p>Usa la funcion <code class="docutils literal notranslate"><span class="pre">inorder_tree()</span></code> para realizar el recorrido.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>my_order_map</strong> (<em>binary_search_tree o red_black_tree</em>) – El arbol binario a recorrer</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Una lista con los nodos del arbol en el orden especificado</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>single_linked_list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DataStructures.Tree.tree_traversal.preorder">
<span class="sig-name descname"><span class="pre">preorder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_order_map</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DataStructures.Tree.tree_traversal.preorder" title="Link to this definition"></a></dt>
<dd><p>Implementa un recorrido preorder de un arbol binario (tanto AVL como BST). El recorrido pasa por los nodos en el siguiente orden: raiz, izquierda, derecha.</p>
<p>Usa la funcion <code class="docutils literal notranslate"><span class="pre">preorder_tree()</span></code> para realizar el recorrido.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>my_order_map</strong> (<em>binary_search_tree o red_black_tree</em>) – El arbol binario a recorrer</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Una lista con los nodos del arbol en el orden especificado</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>single_linked_list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DataStructures.Tree.tree_traversal.postorder">
<span class="sig-name descname"><span class="pre">postorder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">my_order_map</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DataStructures.Tree.tree_traversal.postorder" title="Link to this definition"></a></dt>
<dd><p>Implementa un recorrido postorder de un arbol binario (tanto AVL como BST). El recorrido pasa por los nodos en el siguiente orden: izquierda, derecha, raiz.</p>
<p>Usa la funcion <code class="docutils literal notranslate"><span class="pre">postorder_tree()</span></code> para realizar el recorrido.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>my_order_map</strong> (<em>binary_search_tree o red_black_tree</em>) – El arbol binario a recorrer</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Una lista con los nodos del arbol en el orden especificado</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>single_linked_list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DataStructures.Tree.tree_traversal.inorder_tree">
<span class="sig-name descname"><span class="pre">inorder_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DataStructures.Tree.tree_traversal.inorder_tree" title="Link to this definition"></a></dt>
<dd><p>Realiza un recorrido inorder de un arbol binario (tanto AVL como BST). El recorrido pasa por los nodos en el siguiente orden: izquierda, raiz, derecha.</p>
<p>Es usada por las funciones <code class="docutils literal notranslate"><span class="pre">inorder()</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> (<em>bst_node o rbt_node</em>) – El nodo raiz del arbol</p></li>
<li><p><strong>node_list</strong> (<em>single_linked_list</em>) – La lista de nodos que se va a llenar</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Una lista con los nodos del arbol en el orden especificado</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>single_linked_list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DataStructures.Tree.tree_traversal.postorder_tree">
<span class="sig-name descname"><span class="pre">postorder_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DataStructures.Tree.tree_traversal.postorder_tree" title="Link to this definition"></a></dt>
<dd><p>Realiza un recorrido postorder de un arbol binario (tanto AVL como BST). El recorrido pasa por los nodos en el siguiente orden: izquierda, derecha, raiz.</p>
<p>Es usada por las funciones <code class="docutils literal notranslate"><span class="pre">postorder()</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> (<em>bst_node o rbt_node</em>) – El nodo raiz del arbol</p></li>
<li><p><strong>node_list</strong> (<em>single_linked_list</em>) – La lista de nodos que se va a llenar</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Una lista con los nodos del arbol en el orden especificado</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>single_linked_list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="DataStructures.Tree.tree_traversal.preorder_tree">
<span class="sig-name descname"><span class="pre">preorder_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">node_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#DataStructures.Tree.tree_traversal.preorder_tree" title="Link to this definition"></a></dt>
<dd><p>Realiza un recorrido preorder de un arbol binario (tanto AVL como BST). El recorrido pasa por los nodos en el siguiente orden: raiz, izquierda, derecha.</p>
<p>Es usada por las funciones <code class="docutils literal notranslate"><span class="pre">preorder()</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>root</strong> (<em>bst_node o rbt_node</em>) – El nodo raiz del arbol</p></li>
<li><p><strong>node_list</strong> (<em>single_linked_list</em>) – La lista de nodos que se va a llenar</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Una lista con los nodos del arbol en el orden especificado</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>single_linked_list</p>
</dd>
</dl>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="DataStructures.Map.html" class="btn btn-neutral float-left" title="Map - Tablas" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="DataStructures.Priority_queue.html" class="btn btn-neutral float-right" title="Priority Queue - Colas de prioridad" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Universidad de los Andes.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>