####################################
List - Listas
####################################

Las listas son estructuras de datos que permiten almacenar elementos de manera secuencial. En este módulo se encuentran implementaciones de listas, así como funciones para manipularlas.

Como usar la documentación
#################################################

Para leer la guía de uso de la documentación, por favor diríjase a la sección :ref:`Guía de documentación<guia-doc>`.


Elementos
#################################################

.. _list-node:

list\_node.py
-------------------------------------

Estructura de un nodo de lista encadenada. Un nodo de lista encadenada es un elemento que contiene un valor y una referencia al siguiente nodo.

.. py:function:: new_single_node(element)

   Crea un nodo simple (de tipo :ref:`list_node<list-node>`) con un elemento dado.

   El nodo es creado con los siguientes atributos:

   * **info**: información del nodo, inicializada con el elemento dado.
   * **next**: Referencia al siguiente nodo, inicializada en None.

   :param element: Elemento del nodo.
   :type element: any

   :returns: Nodo recien creado.
   :rtype: :ref:`list_node<list-node>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import list_node as ln

         # Crea un nodo con el elemento 1
         nodo = ln.new_single_node({"nombre": "Juan", "edad": 20})
         print(nodo) 
         # Salida esperada: {'info': {"nombre": "Juan", "edad": 20}, 'next': None}

.. py:function:: get_element(node)

   Retorna la información del nodo.

   :param node: Nodo del cual se obtendrá la información.
   :type node: :ref:`list_node<list-node>`

   :returns: Información del nodo.
   :rtype: any

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import list_node as ln

         # Crea un nodo con el elemento 1
         nodo = ln.new_single_node({"nombre": "Juan", "edad": 20})
         print(nodo) # Salida esperada: {'info': {'nombre': 'Juan', 'edad': 20}, 'next': None}

         # Obtiene la información del nodo
         info = ln.get_element(nodo)
         print(info) # Salida esperada: {'nombre': 'Juan', 'edad': 20}

.. py:function:: get_next(node)

   Retorna la referencia al siguiente nodo.

   :param node: Nodo del cual se obtendrá la referencia al siguiente nodo.
   :type node: :ref:`list_node<list-node>`

   :returns: Referencia al siguiente nodo.
   :rtype: :ref:`list_node<list-node>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import list_node as ln

         # Crea un nodo con el elemento información de Juan
         nodo = ln.new_single_node({"nombre": "Juan", "edad": 20})
         print(nodo) 
         # Salida esperada: {'info': {"nombre": "Juan", "edad": 20}, 'next': None}

         # Obtiene la referencia al siguiente nodo
         next_node = ln.get_next(nodo)
         print(next_node) # Salida esperada: None

         # Crea un nodo con el elemento información de Jairo
         nodo2 = ln.new_single_node({"nombre": "Jairo", "edad": 25})
         nodo["next"] = nodo2
         print(nodo) 
         # Salida esperada: {'info': {"nombre": "Juan", "edad": 20}, 'next': {'info': {"nombre": "Jairo", "edad": 25}, 'next': None}}

         # Obtiene la referencia al siguiente nodo
         next_node = ln.get_next(nodo)
         print(next_node) # Salida esperada: {'info': {"nombre": "Jairo", "edad": 25}, 'next': None}

Implementaciones
#################################################

.. _array-list:

array\_list.py
-----------------------------------------------

.. py:function:: new_list()

   Crea una lista (de tipo :ref:`array_list<array-list>`) vacía.

   La lista es creada con los siguientes atributos:

   * **size**: Tamaño actual de la lista, inicializado en 0.
   * **elements**: Lista de elementos, inicializada en una lista vacía.

   :returns: Lista vacía recien creada.
   :rtype: :ref:`array_list<array-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Crea una lista vacía
         lista = al.new_list()
         print(lista) # Salida esperada: {'size': 0, 'elements': []}

   :Test Scenarios:
      - **Inicialización**: Se crea una lista vacía.

         .. code-block:: json

            {
               "size": 0,
               "elements": []
            }

.. py:function:: is_empty(my_list)
   
   Verifica si la lista está vacía.

   Retorna ``True`` si la lista está vacía, en caso contrario retorna ``False``.

   :param my_list: Lista a verificar.
   :type my_list: :ref:`array_list<array-list>`

   :returns: ``True`` si la lista está vacía, ``False`` en caso contrario.
   :rtype: bool

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Crea una lista vacía
         lista = al.new_list()
         print(al.is_empty(lista)) # Salida esperada: True

         # Agrega un elemento a la lista
         lista = al.add_last(lista, 1)
         print(al.is_empty(lista)) # Salida esperada: False

   :Test Scenarios:
      - **Lista vacía**: Se verifica si la lista está vacía.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Crea una lista vacía
            lista = al.new_list()
            print(al.is_empty(lista)) # Salida esperada: True

      - **Lista con elementos**: Se verifica si la lista con elementos está vacía.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Lista con elementos
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            print(al.is_empty(lista)) # Salida esperada: False

.. py:function:: size(my_list)

   Retorna el tamaño de la lista.

   :param my_list: Lista de la cual se obtendrá el tamaño.
   :type my_list: :ref:`array_list<array-list>`

   :returns: Tamaño de la lista.
   :rtype: int

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Crea una lista vacía
         lista = al.new_list()
         print(al.size(lista)) # Salida esperada: 0

         # Agrega un elemento a la lista
         lista = al.add_last(lista, 1)
         print(al.size(lista)) # Salida esperada: 1

   :Test Scenarios:
      - **Lista vacía**: Se obtiene el tamaño de la lista vacía.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Crea una lista vacía
            lista = al.new_list()
            print(al.size(lista)) # Salida esperada: 0

      - **Lista con elementos**: Se obtiene el tamaño de la lista con elementos.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Lista con elementos
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            print(al.size(lista)) # Salida esperada: 1

.. py:function:: add_first(my_list, element)

   Agrega un elemento al inicio de la lista.

   Inserta el elemento al inicio de la lista y actualiza el tamaño de la lista en 1.

   :param my_list: Lista a la cual se le agregará el elemento.
   :type my_list: :ref:`array_list<array-list>`
   :param element: Elemento a agregar.
   :type element: any

   :returns: Lista con el elemento agregado al inicio.
   :rtype: :ref:`array_list<array-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Crea una lista vacía
         lista = al.new_list()
         print(lista) # Salida esperada: {'size': 0, 'elements': []}

         # Agrega un elemento al inicio
         lista = al.add_first(lista, 1)
         print(lista) # Salida esperada: {'size': 1, 'elements': [1]}

   :Test Scenarios:
      - **Agrega en una lista vacia**: Se agrega un elemento al inicio de la lista vacía.

         .. code-block:: json

            {
               "size": 1,
               "elements": [1]
            }

      - **Agrega en una lista con elementos**: Se agrega un elemento al inicio de la lista con elementos.

         .. code-block:: python
            
            # App/logic.py
            from DataStructures.List import array_list as al

            # Lista con elementos
            lista = al.new_list()
            lista = al.add_first(lista, 1)

            # Agrega un elemento al inicio
            lista = al.add_first(lista, 2)
            print(lista) # Salida esperada: {'size': 2, 'elements': [2, 1]}

.. py:function:: add_last(my_list, element)

   Agrega un elemento al final de la lista.

   Inserta el elemento al final de la lista y aumenta el tamaño de la lista en 1.

   :param my_list: Lista a la cual se le agregará el elemento.
   :type my_list: :ref:`array_list<array-list>`
   :param element: Elemento a agregar.
   :type element: any

   :returns: Lista con el elemento agregado al final.
   :rtype: :ref:`array_list<array-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Crea una lista vacía
         lista = al.new_list()
         print(lista) # Salida esperada: {'size': 0, 'elements': []}

         # Agrega un elemento al final
         lista = al.add_last(lista, 1)
         print(lista) # Salida esperada: {'size': 1, 'elements': [1]}

   :Test Scenarios:
      - **Agrega un elemento al final**: Se agrega un elemento al final de la lista vacía.

         .. code-block:: json

            {
               "size": 1,
               "elements": [1]
            }

      - **Agrega un elemento al final**: Se agrega un elemento al final de la lista con elementos.

         .. code-block:: python
            
            # App/logic.py
            from DataStructures.List import array_list as al

            # Lista con elementos
            lista = al.new_list()
            lista = al.add_last(lista, 1)

            # Agrega un elemento al final
            lista = al.add_last(lista, 2)
            print(lista) # Salida esperada: {'size': 2, 'elements': [1, 2]}


.. py:function:: first_element(my_list)

   Retorna el primer elemento de una lista no vacía.

   Retorna el primer elemento de la lista. Si la lista está vacía, lanza un error :code:`IndexError: list index out of range`.
   Esta función no elimina el elemento de la lista.

   :param my_list: Lista de la cual se obtendrá el primer elemento.
   :type my_list: :ref:`array_list<array-list>`

   :returns: Primer elemento de la lista.
   :rtype: any

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Crea una lista vacía
         lista = al.new_list()

         # Agrega un elemento al inicio
         lista = al.add_first(lista, 1)
         print(al.first_element(lista)) # Salida esperada: 1

   :Test Scenarios:
      - **Lista vacía**: Lanza un error al intentar obtener el primer elemento de la lista vacía.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Crea una lista vacía
            lista = al.new_list()
            print(al.first_element(lista)) 
            # Salida esperada: "IndexError: list index out of range"

      - **Lista con elementos**: Se obtiene el primer elemento de la lista con elementos.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Lista con elementos
            lista = al.new_list()
            lista = al.add_first(lista, 2)
            lista = al.add_first(lista, 1)
            print(al.first_element(lista)) # Salida esperada: 1

.. py:function:: last_element(my_list)
   
   Retorna el último elemento de la lista no vacía.

   Retorna el último elemento de la lista. Si la lista está vacía, lanza un error :code:`IndexError: list index out of range`.
   Esta función no elimina el elemento de la lista.

   :param my_list: Lista de la cual se obtendrá el último elemento.
   :type my_list: :ref:`array_list<array-list>`

   :returns: Último elemento de la lista.
   :rtype: any

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Crea una lista vacía
         lista = al.new_list()

         # Agrega un elemento al final
         lista = al.add_last(lista, 1)
         lista = al.add_last(lista, 2)
         print(al.last_element(lista)) # Salida esperada: 2

   :Test Scenarios:
      - **Lista vacía**: Lanza un error al intentar obtener el último elemento de la lista vacía.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Crea una lista vacía
            lista = al.new_list()
            print(al.last_element(lista))
            # Salida esperada: "IndexError: list index out of range"

      - **Lista con elementos**: Se obtiene el último elemento de la lista con elementos.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Lista con elementos
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            print(al.last_element(lista)) # Salida esperada: 1

.. py:function:: get_element(my_list, pos)

   Retorna el elemento en la posición dada.

   Retorna el elemento en la posición ``pos``, la cual debe ser igual o mayor a cero y menor al tamaño de la lista. :code:`0 <= pos < size(my_list)`.
   Si la posición no es válida, lanza un error :code:`IndexError: list index out of range`.
   Esta función no elimina el elemento de la lista.

   :param my_list: Lista de la cual se obtendrá el elemento.
   :type my_list: :ref:`array_list<array-list>`
   :param pos: Posición del elemento a obtener.
   :type pos: int

   :returns: Elemento en la posición dada.
   :rtype: any

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Crea una lista vacía
         lista = al.new_list()

         # Agrega un elemento al final
         lista = al.add_last(lista, 1)
         lista = al.add_last(lista, 2)
         print(al.get_element(lista, 1)) # Salida esperada: 2

   :Test Scenarios:
      - **Posición inválida**: Se obtiene el elemento en una posición inválida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Crea una lista vacía
            lista = al.new_list()
            print(al.get_element(lista, 0))
            # Salida esperada: "IndexError: list index out of range"

      - **Posición válida**: Se obtiene el elemento en una posición válida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Lista con elementos
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)
            print(al.get_element(lista, 1)) # Salida esperada: 2

.. py:function:: delete_element(my_list, pos)

   Elimina el elemento en la posición dada.

   Elimina el elemento en la posición ``pos``, la cual debe ser igual o mayor a cero y menor al tamaño de la lista. :code:`0 <= pos < size(my_list)`.
   Si la posición no es válida, lanza un error :code:`IndexError: list index out of range`.

   :param my_list: Lista de la cual se eliminará el elemento.
   :type my_list: :ref:`array_list<array-list>`
   :param pos: Posición del elemento a eliminar.
   :type pos: int

   :returns: Lista con el elemento eliminado.
   :rtype: :ref:`array_list<array-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Crea una lista vacía
         lista = al.new_list()

         # Agrega un elemento al final
         lista = al.add_last(lista, 1)
         lista = al.add_last(lista, 2)
         print(lista) # Salida esperada: {'size': 2, 'elements': [1, 2]}

         # Elimina el elemento en la posición 1
         print(al.delete_element(lista, 1)) # Salida esperada: {'size': 1, 'elements': [1]}

   :Test Scenarios:
      - **Posición inválida**: Se elimina el elemento en una posición inválida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Crea una lista vacía
            lista = al.new_list()
            print(al.delete_element(lista, 0))
            # Salida esperada: "IndexError: list index out of range"

      - **Posición válida**: Se elimina el elemento en una posición válida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Lista con elementos
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)
            print(al.delete_element(lista, 1)) # Salida esperada: {'size': 1, 'elements': [1]}


.. py:function:: remove_first(my_list)

   Elimina el primer elemento de la lista.

   Elimina el primer elemento de la lista y disminuye el tamaño de la lista en 1.
   Si la lista está vacía, lanza un error :code:`IndexError: list index out of range`.

   :param my_list: Lista de la cual se eliminará el primer elemento.
   :type my_list: :ref:`array_list<array-list>`

   :returns: Elemento recien eliminado.
   :rtype: any

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Crea una lista vacía
         lista = al.new_list()

         # Agrega un elemento al final
         lista = al.add_last(lista, 1)
         lista = al.add_last(lista, 2)
         print(lista) # Salida esperada: {'size': 2, 'elements': [1, 2]}

         # Elimina el primer elemento
         print(al.remove_first(lista)) # Salida esperada: 1

   :Test Scenarios:
      - **Lista vacía**: Lanza un error al intentar eliminar el primer elemento de la lista vacía.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Crea una lista vacía
            lista = al.new_list()
            print(al.remove_first(lista))
            # Salida esperada: "IndexError: list index out of range"

      - **Lista con elementos**: Se elimina el primer elemento de la lista con elementos.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Lista con elementos
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)
            print(al.remove_first(lista)) # Salida esperada: 1

.. py:function:: remove_last(my_list)

   Elimina el último elemento de la lista.

   Elimina el último elemento de la lista y disminuye el tamaño de la lista en 1.
   Si la lista está vacía, lanza un error :code:`IndexError: list index out of range`.

   :param my_list: Lista de la cual se eliminará el último elemento.
   :type my_list: :ref:`array_list<array-list>`

   :returns: Elemento recien eliminado.
   :rtype: any

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Crea una lista vacía
         lista = al.new_list()

         # Agrega un elemento al final
         lista = al.add_last(lista, 1)
         lista = al.add_last(lista, 2)
         print(lista) # Salida esperada: {'size': 2, 'elements': [1, 2]}

         # Elimina el último elemento
         print(al.remove_last(lista)) # Salida esperada: 2

   :Test Scenarios:
      - **Lista vacía**: Lanza un error al intentar eliminar el último elemento de la lista vacía.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Crea una lista vacía
            lista = al.new_list()
            print(al.remove_last(lista))
            # Salida esperada: "IndexError: list index out of range"

      - **Lista con elementos**: Se elimina el último elemento de la lista con elementos.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Lista con elementos
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)
            print(al.remove_last(lista)) # Salida esperada: 2

.. py:function:: insert_element(my_list, element, pos)

   Inserta un elemento en la posición dada.

   Inserta el elemento en la posición ``pos``. La lista puede estar vacia o tener elementos.
   Se incrementa el tamaño de la lista en 1.

   :param my_list: Lista en la cual se insertará el elemento.
   :type my_list: :ref:`array_list<array-list>`
   :param element: Elemento a insertar.
   :type element: any
   :param pos: Posición en la cual se insertará el elemento.
   :type pos: int

   :returns: Lista con el elemento insertado.
   :rtype: :ref:`array_list<array-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Crea una lista vacía
         lista = al.new_list()

         # Agrega un elemento al final
         lista = al.add_last(lista, 1)
         lista = al.add_last(lista, 3)
         print(lista) # Salida esperada: {'size': 2, 'elements': [1, 3]}

         # Inserta el elemento 2 en la posición 1
         print(al.insert_element(lista, 2, 1)) # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

   :Test Scenarios:
      
      - **Lista vacia**: Se inserta un elemento en una lista vacía.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Crea una lista vacía
            lista = al.new_list()
            print(al.insert_element(lista, 1, 0)) # Salida esperada: {'size': 1, 'elements': [1]}

      - **Lista con elementos**: Se inserta un elemento en una lista con elementos.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Lista con elementos
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 3)
            print(al.insert_element(lista, 2, 1)) # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

.. _default-function-array:

.. py:function:: default_function(element_1, element_2)

   Función de comparación por defecto a modo de ejemplo.

   Esta función de comparación por defecto compara dos elementos y retorna ``0`` si son iguales, ``1`` si el ``element_1`` es mayor que ``element_2`` y ``-1`` si ``element_1`` es menor que ``element_2``.

   .. admonition:: Importante
      :class: note

      Una ``cmp_function`` es una función de comparación que recibe dos elementos y retorna un valor entero. 
      Use esta función como referencia para crear su propia función de comparación donde los criterios de comparación pueden ser definidos dependiendo del tipo de elementos y su contexto. 

   :param element_1: Primer elemento a comparar.
   :type element_1: any
   :param element_2: Segundo elemento a comparar.
   :type element_2: any

   :returns: ``0`` si los elementos son iguales, ``1`` si el primer elemento es mayor que el segundo y ``-1`` en caso contrario.
   :rtype: int

   :Code example:
      .. code-block:: python

         def default_function(elemen_1, element_2):
  
            if elemen_1 > element_2:
               return 1
            elif elemen_1 < element_2:
               return -1
            return 0


.. py:function:: is_present(my_list, element, cmp_function)
   
   Verifica si un elemento está presente en la lista.

   Para comparar los elementos, se utiliza la función de comparación ``cmp_function``.
   Si el elemento está presente retorna su posición, en caso contrario retorna ``-1``.

   .. admonition:: Importante
      :class: note

      Una ``cmp_function`` es una función de comparación que recibe dos elementos y retorna un valor entero. Este valor entero debe ser ``0`` si los elementos son iguales, ``1`` si el primer elemento es mayor que el segundo y ``-1`` en caso contrario.
      Use la función de comparación por defecto :ref:`default_function<default-function-array>` como referencia para crear su propia función de comparación.

   :param my_list: Lista en la cual se buscará el elemento.
   :type my_list: :ref:`array_list<array-list>`
   :param element: Elemento a buscar.
   :type element: any
   :param cmp_function: Función de comparación.
   :type cmp_function: function

   :returns: Posición del elemento si está presente, ``-1`` en caso contrario.
   :rtype: int

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Función de comparación por defecto
         cmp_function = al.default_function

         # Crea una lista vacía
         lista = al.new_list()

         # Agrega un elemento al final
         lista = al.add_last(lista, 1)
         lista = al.add_last(lista, 2)
         print(al.is_present(lista, 2, cmp_function))
         # Salida esperada: 1

   :Test Scenarios:
      - **Elemento presente**: Se verifica si un elemento está presente en la lista.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Función de comparación por defecto
            cmp_function = al.default_function

            # Lista con elementos
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)
            print(al.is_present(lista, 2, cmp_function))
            # Salida esperada: 1

      - **Elemento no presente**: Se verifica si un elemento no está presente en la lista.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Función de comparación por defecto
            cmp_function = al.default_function

            # Lista con elementos
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)
            print(al.is_present(lista, 3, cmp_function))
            # Salida esperada: -1

.. py:function:: change_info(my_list, pos, new_info)

   Cambia la información de un elemento en la posición dada.

   Cambia la información del elemento en la posición ``pos`` por la información ``new_info``.
   Si la posición no es válida, lanza un error :code:`IndexError: list index out of range`.

   :param my_list: Lista en la cual se cambiará la información del elemento.
   :type my_list: :ref:`array_list<array-list>`
   :param pos: Posición del elemento a cambiar.
   :type pos: int
   :param new_info: Nueva información del elemento.
   :type new_info: any

   :returns: Lista con la información del elemento cambiada.
   :rtype: :ref:`array_list<array-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Crea una lista vacía
         lista = al.new_list()

         # Agrega un elemento al final
         lista = al.add_last(lista, 1)
         lista = al.add_last(lista, 2)
         print(lista) # Salida esperada: {'size': 2, 'elements': [1, 2]}

         # Cambia la información del elemento en la posición 1
         print(al.change_info(lista, 1, 3)) # Salida esperada: {'size': 2, 'elements': [1, 3]}

   :Test Scenarios:
      - **Posición inválida**: Se cambia la información de un elemento en una posición inválida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Crea una lista vacía
            lista = al.new_list()
            print(al.change_info(lista, 0, 1))
            # Salida esperada: "IndexError: list index out of range"

      - **Posición válida**: Se cambia la información de un elemento en una posición válida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Lista con elementos
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)
            print(al.change_info(lista, 1, 3)) # Salida esperada: {'size': 2, 'elements': [1, 3]}

.. py:function:: exchange(my_list, pos_1, pos_2)

   Intercambia la información de dos elementos en las posiciones dadas.

   Intercambia la información de los elementos en las posiciones ``pos_1`` y ``pos_2``.
   Si alguna de las posiciones no es válida, lanza un error :code:`IndexError: list index out of range`.

   :param my_list: Lista en la cual se intercambiará la información de los elementos.
   :type my_list: :ref:`array_list<array-list>`
   :param pos_1: Posición del primer elemento a intercambiar.
   :type pos_1: int
   :param pos_2: Posición del segundo elemento a intercambiar.
   :type pos_2: int

   :returns: Lista con la información de los elementos intercambiada.
   :rtype: :ref:`array_list<array-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Crea una lista vacía
         lista = al.new_list()

         # Agrega elementos a la lista
         lista = al.add_last(lista, 1)
         lista = al.add_last(lista, 2)
         lista = al.add_last(lista, 3)
         print(lista) # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

         # Intercambia la información de los elementos en las posiciones 0 y 2
         print(al.exchange(lista, 0, 2)) # Salida esperada: {'size': 3, 'elements': [3, 2, 1]}

   :Test Scenarios:
      - **Posiciones inválidas**: Se intercambia la información de dos elementos en posiciones inválidas.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Crea una lista vacía
            lista = al.new_list()
            print(al.exchange(lista, 0, 1))
            # Salida esperada: "IndexError: list index out of range"

      - **Posiciones válidas**: Se intercambia la información de dos elementos en posiciones válidas.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Lista con elementos
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)
            lista = al.add_last(lista, 3)
            print(al.exchange(lista, 0, 2)) # Salida esperada: {'size': 3, 'elements': [3, 2, 1]}

.. py:function:: sub_list(my_list, pos_i, num_elements)

   Retorna una sublista de la lista original.

   Retorna una sublista de la lista original que inicia en la posición ``pos_i`` y contiene ``num_elements`` elementos.
   Si la posición inicial no es válida, lanza un error :code:`IndexError: list index out of range`.

   :param my_list: Lista de la cual se obtendrá la sublista.
   :type my_list: :ref:`array_list<array-list>`
   :param pos_i: Posición inicial de la sublista.
   :type pos_i: int
   :param num_elements: Número de elementos de la sublista.
   :type num_elements: int

   :returns: Sublista de la lista original.
   :rtype: :ref:`array_list<array-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Crea una lista vacía
         lista = al.new_list()

         # Agrega elementos a la lista
         lista = al.add_last(lista, 1)
         lista = al.add_last(lista, 2)
         lista = al.add_last(lista, 3)
         print(lista) # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

         # Obtiene la sublista de la lista original
         print(al.sub_list(lista, 1, 2)) # Salida esperada: {'size': 2, 'elements': [2, 3]}

   :Test Scenarios:
      - **Posición inicial inválida**: Se obtiene una sublista de la lista original con una posición inicial inválida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Crea una lista vacía
            lista = al.new_list()
            print(al.sub_list(lista, 0, 1))
            # Salida esperada: "IndexError: list index out of range"

      - **Posición inicial válida**: Se obtiene una sublista de la lista original con una posición inicial válida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Lista con elementos
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)
            lista = al.add_last(lista, 3)
            print(al.sub_list(lista, 1, 2)) 
            # Salida esperada: {'size': 2, 'elements': [2, 3]}


.. _single-linked-list:

single\_linked\_list.py
-----------------------------------------------

.. .. automodule:: DataStructures.List.single_linked_list
..    :members:
..    :undoc-members:
..    :show-inheritance:
..    :member-order: bysource

.. py:function:: new_list()

   Crea una lista (de tipo :ref:`single_linked_list<single-linked-list>`) vacía.

   La lista es creada con los siguientes atributos:

   * **size**: Tamaño actual de la lista, inicializado en 0.
   * **first**: Primer nodo de la lista, inicializado en ``None``.
   * **last**: Último nodo de la lista, inicializado en ``None``.

   :returns: Lista vacía recien creada.
   :rtype: :ref:`single_linked_list<single-linked-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import single_linked_list as sll

         # Crea una lista vacía
         lista = sll.new_list()
         print(lista) 
         # Salida esperada: {'size': 0, 'first': None, 'last': None}

   :Test Scenarios:
      - **Crea una lista vacía**: Se crea una lista vacía.

         .. code-block:: json

            {
               "size": 0,
               "first": None,
               "last": None
            }

.. py:function:: is_empty(my_list)

   Verifica si la lista está vacía.

   Retorna ``True`` si la lista está vacía, en caso contrario retorna ``False``.

   :param my_list: Lista a verificar.
   :type my_list: :ref:`single_linked_list<single-linked-list>`

   :returns: ``True`` si la lista está vacía, ``False`` en caso contrario.
   :rtype: bool

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import single_linked_list as sll

         # Crea una lista vacía
         lista = sll.new_list()
         print(sll.is_empty(lista)) # Salida esperada: True

   :Test Scenarios:
      - **Lista vacía**: Se verifica si una lista está vacía.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Crea una lista vacía
            lista = sll.new_list()
            print(sll.is_empty(lista))
            # Salida esperada: True

      - **Lista con elementos**: Se verifica si una lista con elementos está vacía.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Lista con elementos
            lista = sll.new_list()
            lista = sll.add_last(lista, 1)
            print(sll.is_empty(lista))
            # Salida esperada: False


.. py:function:: size(my_list)

   Retorna el tamaño de la lista.

   :param my_list: Lista de la cual se obtendrá el tamaño.
   :type my_list: :ref:`single_linked_list<single-linked-list>`

   :returns: Tamaño de la lista.
   :rtype: int

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import single_linked_list as sll

         # Crea una lista vacía
         lista = sll.new_list()
         print(sll.size(lista)) # Salida esperada: 0

   :Test Scenarios:
      - **Lista vacía**: Se obtiene el tamaño de una lista vacía.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Crea una lista vacía
            lista = sll.new_list()
            print(sll.size(lista))
            # Salida esperada: 0

      - **Lista con elementos**: Se obtiene el tamaño de una lista con elementos.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Lista con elementos
            lista = sll.new_list()
            lista = sll.add_last(lista, 1)
            print(sll.size(lista))
            # Salida esperada: 1   


.. py:function:: add_first(my_list, element)

   Agrega un elemento al inicio de la lista.

   Agrega un nuevo nodo al inicio de la lista y aumenta el tamaño de la lista en 1.
   En caso de que la lista esté vacía, el primer y último nodo de la lista serán el nuevo nodo.

   :param my_list: Lista a la cual se agregará el elemento.
   :type my_list: :ref:`single_linked_list<single-linked-list>`
   :param element: Elemento a agregar.
   :type element: any

   :returns: Lista con el elemento agregado al inicio.
   :rtype: :ref:`single_linked_list<single-linked-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import single_linked_list as sll

         # Crea una lista vacía
         lista = sll.new_list()
         lista = sll.add_first(lista, 1)
         print(lista) 
         # Salida esperada: 
         # {'size': 1, 
         #  'first': {'info': 1, 'next': None}, 
         #  'last': {'info': 1, 'next': None}
         # }

   :Test Scenarios:
      - **Agrega en una lista vacia**: Se agrega un elemento al inicio de la lista vacía.

         .. code-block:: json

            {
               "size": 1,
               "first": {
                  "info": 1,
                  "next": None
               },
               "last": {
                  "info": 1,
                  "next": None
               }
            }

      - **Agrega en una lista con elementos**: Se agrega un elemento al inicio de la lista con elementos.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Lista con elementos
            lista = sll.new_list()
            lista = sll.add_first(lista, 1)
            lista = sll.add_first(lista, 2)
            print(lista) 
            # Salida esperada: 
            # {'size': 2, 
            #  'first': {'info': 2, 'next': {'info': 1, 'next': None}}, 
            #  'last': {'info': 1, 'next': None}
            #}


.. py:function:: add_last(my_list, element)

   Agrega un elemento al final de la lista.

   Agrega un nuevo nodo al final de la lista y aumenta el tamaño de la lista en 1.
   En caso de que la lista esté vacía, el primer y último nodo de la lista serán el nuevo nodo.

   :param my_list: Lista a la cual se agregará el elemento.
   :type my_list: :ref:`single_linked_list<single-linked-list>`
   :param element: Elemento a agregar.
   :type element: any

   :returns: Lista con el elemento agregado al final.
   :rtype: :ref:`single_linked_list<single-linked-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import single_linked_list as sll

         # Crea una lista vacía
         lista = sll.new_list()
         lista = sll.add_last(lista, 1)
         print(lista) 
         # Salida esperada: 
         # {'size': 1, 
         #  'first': {'info': 1, 'next': None}, 
         #  'last': {'info': 1, 'next': None}
         # }

   :Test Scenarios:
      - **Agrega en una lista vacia**: Se agrega un elemento al final de la lista vacía.

         .. code-block:: json

            {
               "size": 1,
               "first": {
                  "info": 1,
                  "next": None
               },
               "last": {
                  "info": 1,
                  "next": None
               }
            }

      - **Agrega en una lista con elementos**: Se agrega un elemento al final de la lista con elementos.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Lista con elementos
            lista = sll.new_list()
            lista = sll.add_last(lista, 1)
            lista = sll.add_last(lista, 2)
            print(lista) 
            # Salida esperada: 
            # {'size': 2, 
            #  'first': {'info': 1, 'next': {'info': 2, 'next': None}}, 
            #  'last': {'info': 2, 'next': None}
            # }


.. py:function:: first_element(my_list)

   Retorna el primer elemento de una lista no vacía.

   Retorna el primer elemento de la lista. Si la lista está vacía, lanza un error :code:`IndexError: list index out of range`.
   Esta función no elimina el elemento de la lista.

   .. admonition:: Importante
      :class: note

      Para lanzar un error si la lista está vacía, puede utilizar el siguiente código:

      .. code-block:: python

         if is_empty(my_list):
            raise Exception('IndexError: list index out of range')

   :param my_list: Lista de la cual se obtendrá el primer elemento.
   :type my_list: :ref:`single_linked_list<single-linked-list>`

   :returns: Primer elemento de la lista.
   :rtype: any

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import single_linked_list as sll

         # Crea una lista vacía
         lista = sll.new_list()
         lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
         lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
         print(sll.first_element(lista)) 
         # Salida esperada: {'name': 'Uno', 'number': 1}

   :Test Scenarios:
      - **Lista vacía**: Se obtiene el primer elemento de una lista vacía.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Crea una lista vacía
            lista = sll.new_list()
            print(sll.first_element(lista))
            # Salida esperada: "IndexError: list index out of range"

      - **Lista con elementos**: Se obtiene el primer elemento de una lista con elementos.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Lista con elementos
            lista = sll.new_list()
            lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
            lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
            print(sll.first_element(lista))
            # Salida esperada: {'name': 'Uno', 'number': 1}


.. py:function:: last_element(my_list)

   Retorna el último elemento de una lista no vacía.

   Retorna el último elemento de la lista. Si la lista está vacía, lanza un error :code:`IndexError: list index out of range`.
   Esta función no elimina el elemento de la lista.

   .. admonition:: Importante
      :class: note

      Para lanzar un error si la lista está vacía, puede utilizar el siguiente código:

      .. code-block:: python

         if is_empty(my_list):
            raise Exception('IndexError: list index out of range')

   :param my_list: Lista de la cual se obtendrá el último elemento.
   :type my_list: :ref:`single_linked_list<single-linked-list>`

   :returns: Último elemento de la lista.
   :rtype: any

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import single_linked_list as sll

         # Crea una lista vacía
         lista = sll.new_list()
         lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
         lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
         print(sll.last_element(lista)) 
         # Salida esperada: {'name': 'Dos', 'number': 2}

   :Test Scenarios:
      - **Lista vacía**: Se obtiene el último elemento de una lista vacía.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Crea una lista vacía
            lista = sll.new_list()
            print(sll.last_element(lista))
            # Salida esperada: "IndexError: list index out of range"

      - **Lista con elementos**: Se obtiene el último elemento de una lista con elementos.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Lista con elementos
            lista = sll.new_list()
            lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
            lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
            print(sll.last_element(lista))
            # Salida esperada: {'name': 'Dos', 'number': 2}


.. py:function:: get_element(my_list, pos)

   Retorna el elemento en la posición dada.

   Retorna el elemento en la posición ``pos``, la cual debe ser igual o mayor a cero y menor al tamaño de la lista. :code:`0 <= pos < size(my_list)`.
   Si la posición no es válida, lanza un error :code:`IndexError: list index out of range`.
   Esta función no elimina el elemento de la lista.

   .. admonition:: Importante
      :class: note

      Para lanzar un error si la posición no es válida, puede utilizar el siguiente código:

      .. code-block:: python

         if pos < 0 or pos >= size(my_list):
            raise Exception('IndexError: list index out of range')

   :param my_list: Lista de la cual se obtendrá el elemento.
   :type my_list: :ref:`single_linked_list<single-linked-list>`
   :param pos: Posición del elemento a obtener.
   :type pos: int

   :returns: Elemento en la posición dada.
   :rtype: any

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import single_linked_list as sll

         # Crea una lista vacía
         lista = sll.new_list()
         lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
         lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
         lista = sll.add_last(lista, {'name': 'Tres', 'number': 3})
         print(sll.get_element(lista, 1)) 
         # Salida esperada: {'name': 'Dos', 'number': 2}

   :Test Scenarios:
      - **Posición inválida**: Se obtiene un elemento en una posición inválida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Crea una lista vacía
            lista = sll.new_list()
            print(sll.get_element(lista, 3))
            # Salida esperada: "IndexError: list index out of range"

      - **Posición válida**: Se obtiene un elemento en una posición válida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Lista con elementos
            lista = sll.new_list()
            lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
            lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
            lista = sll.add_last(lista, {'name': 'Tres', 'number': 3})
            print(sll.get_element(lista, 1))
            # Salida esperada: {'name': 'Dos', 'number': 2}

.. py:function:: delete_element(my_list, pos)

   Elimina un elemento en la posición dada.

   Elimina el elemento en la posición ``pos``, la cual debe ser igual o mayor a cero y menor al tamaño de la lista. :code:`0 <= pos < size(my_list)`
   Si la posición no es válida, lanza un error :code:`IndexError: list index out of range`.

   .. admonition:: Importante
      :class: note

      Para lanzar un error si la posición no es válida, puede utilizar el siguiente código:

      .. code-block:: python

         if pos < 0 or pos >= size(my_list):
            raise Exception('IndexError: list index out of range')

   :param my_list: Lista de la cual se eliminará el elemento.
   :type my_list: :ref:`single_linked_list<single-linked-list>`
   :param pos: Posición del elemento a eliminar.
   :type pos: int

   :returns: Lista con el elemento eliminado.
   :rtype: :ref:`single_linked_list<single-linked-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import single_linked_list as sll

         # Crea una lista vacía
         lista = sll.new_list()
         lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
         lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
         lista = sll.add_last(lista, {'name': 'Tres', 'number': 3})
         print(sll.delete_element(lista, 1)) 
         # Salida esperada: 
         # {'size': 2, 
         #  'first': {'info': {'name': 'Uno', 'number': 1}, 'next': {'info': {'name': 'Tres', 'number': 3}, 'next': None}}, 
         #  'last': {'info': {'name': 'Tres', 'number': 3}, 'next': None}
         # }

   :Test Scenarios:
      - **Posición inválida**: Se elimina un elemento en una posición inválida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Crea una lista vacía
            lista = sll.new_list()
            print(sll.delete_element(lista, 3))
            # Salida esperada: "IndexError: list index out of range"

      - **Posición válida**: Se elimina un elemento en una posición válida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Lista con elementos
            lista = sll.new_list()
            lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
            lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
            lista = sll.add_last(lista, {'name': 'Tres', 'number': 3})

            print(sll.delete_element(lista, 1))
            # Salida esperada:
            # {'size': 2,
            #  'first': {'info': {'name': 'Uno', 'number': 1}, 'next': {'info': {'name': 'Tres', 'number': 3}, 'next': None}},
            #  'last': {'info': {'name': 'Tres', 'number': 3}, 'next': None}
            # }

.. py:function:: remove_first(my_list)

   Elimina el primer elemento de la lista.

   Elimina el primer elemento de la lista y disminuye el tamaño de la lista en 1.
   Si la lista está vacía, lanza un error :code:`IndexError: list index out of range`.

   :param my_list: Lista de la cual se eliminará el primer elemento.
   :type my_list: :ref:`single_linked_list<single-linked-list>`

   :returns: Element eliminado de la lista.
   :rtype: any

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import single_linked_list as sll

         # Crea una lista vacía
         lista = sll.new_list()
         lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
         lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
         print(sll.remove_first(lista)) 
         # Salida esperada: 
         # {'name': 'Uno', 'number': 1}

   :Test Scenarios:
      - **Lista vacía**: Se elimina el primer elemento de una lista vacía.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Crea una lista vacía
            lista = sll.new_list()
            print(sll.remove_first(lista))
            # Salida esperada: "IndexError: list index out of range"

      - **Lista con elementos**: Se elimina el primer elemento de una lista con elementos.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Lista con elementos
            lista = sll.new_list()
            lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
            lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
            print(sll.remove_first(lista))
            # Salida esperada:
            # {'name': 'Uno', 'number': 1}

.. py:function:: remove_last(my_list)

   Elimina el último elemento de la lista.

   Elimina el último elemento de la lista y disminuye el tamaño de la lista en 1.
   Si la lista está vacía, lanza un error :code:`IndexError: list index out of range`.

   :param my_list: Lista de la cual se eliminará el último elemento.
   :type my_list: :ref:`single_linked_list<single-linked-list>`

   :returns: Element eliminado de la lista.
   :rtype: any

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import single_linked_list as sll

         # Crea una lista vacía
         lista = sll.new_list()
         lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
         lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
         print(sll.remove_last(lista)) 
         # Salida esperada: 
         # {'name': 'Dos', 'number': 2}

   :Test Scenarios:
      - **Lista vacía**: Se elimina el último elemento de una lista vacía.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Crea una lista vacía
            lista = sll.new_list()
            print(sll.remove_last(lista))
            # Salida esperada: "IndexError: list index out of range"

      - **Lista con elementos**: Se elimina el último elemento de una lista con elementos.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Lista con elementos
            lista = sll.new_list()
            lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
            lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
            print(sll.remove_last(lista))
            # Salida esperada:
            # {'name': 'Dos', 'number': 2}

.. py:function:: insert_element(my_list, element, pos)

   Inserta un elemento en la posición dada.

   Inserta el elemento en la posición ``pos``, la cual debe ser igual o mayor a cero y menor o igual al tamaño de la lista. :code:`0 <= pos <= size(my_list)`.
   Se incrementa el tamaño de la lista en 1.

   .. admonition:: Importante
      :class: note

      Para lanzar un error si la posición no es válida, puede utilizar el siguiente código:

      .. code-block:: python

         if pos < 0 or pos > size(my_list):
            raise Exception('IndexError: list index out of range')

   :param my_list: Lista en la cual se insertará el elemento.
   :type my_list: :ref:`single_linked_list<single-linked-list>`
   :param element: Elemento a insertar.
   :type element: any
   :param pos: Posición en la cual se insertará el elemento.
   :type pos: int

   :returns: Lista con el elemento insertado.
   :rtype: :ref:`single_linked_list<single-linked-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import single_linked_list as sll

         # Crea una lista vacía
         lista = sll.new_list()
         lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
         lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
         lista = sll.insert_element(lista, {'name': 'Tres', 'number': 3}, 1)
         print(lista) 
         # Salida esperada: 
         # {'size': 3, 
         #  'first': {'info': {'name': 'Uno', 'number': 1}, 'next': {'info': {'name': 'Tres', 'number': 3}, 'next': {'info': {'name': 'Dos', 'number': 2}, 'next': None}}}, 
         #  'last': {'info': {'name': 'Dos', 'number': 2}, 'next': None}
         # }

   :Test Scenarios:
      - **Posición inválida**: Se inserta un elemento en una posición inválida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Crea una lista vacía
            lista = sll.new_list()
            print(sll.insert_element(lista, {'name': 'Uno', 'number': 1}, 3))
            # Salida esperada: "IndexError: list index out of range"

      - **Posición válida**: Se inserta un elemento en una posición válida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Lista con elementos
            lista = sll.new_list()
            lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
            lista = sll.add_last(lista, {'name': 'Tres', 'number': 3})
            lista = sll.insert_element(lista, {'name': 'Dos', 'number': 2}, 1)
            print(lista)
            # Salida esperada:
            # {'size': 3,
            #  'first': {'info': {'name': 'Uno', 'number': 1}, 
            #            'next': {'info': {'name': 'Dos', 'number': 2}, 
            #                     'next': {'info': {'name': 'Tres', 'number': 3}, 
            #                              'next': None
            #                             }
            #                    }
            #           },
            #  'last': {'info': {'name': 'Tres', 'number': 3}, 'next': None}
            # }

.. _default-function-single-linked:

.. py:function:: default_function(element_1, element_2)

   Función de comparación por defecto a modo de ejemplo.

   Esta función de comparación por defecto compara dos elementos y retorna ``0`` si son iguales, ``1`` si el ``element_1`` es mayor que ``element_2`` y ``-1`` si ``element_1`` es menor que ``element_2``.

   .. admonition:: Importante
      :class: note

      Una ``cmp_function`` es una función de comparación que recibe dos elementos y retorna un valor entero. 
      Use esta función como referencia para crear su propia función de comparación donde los criterios de comparación pueden ser definidos dependiendo del tipo de elementos y su contexto. 

   :param element_1: Primer elemento a comparar.
   :type element_1: any
   :param element_2: Segundo elemento a comparar.
   :type element_2: any

   :returns: ``0`` si los elementos son iguales, ``1`` si el primer elemento es mayor que el segundo y ``-1`` en caso contrario.
   :rtype: int

   :Code example:
      .. code-block:: python

         def default_function(elemen_1, element_2):
  
            if elemen_1 > element_2:
               return 1
            elif elemen_1 < element_2:
               return -1
            return 0

.. py:function:: is_present(my_list, element, cmp_function)

   Verifica si un elemento está presente en la lista.

   Para comparar los elementos, se utiliza la función de comparación ``cmp_function``.
   Si el elemento está presente retorna su posición, en caso contrario retorna ``-1``.

   .. admonition:: Importante
      :class: note

      Una ``cmp_function`` es una función de comparación que recibe dos elementos y retorna un valor entero. Este valor entero debe ser ``0`` si los elementos son iguales, ``1`` si el primer elemento es mayor que el segundo y ``-1`` en caso contrario.
      Use la función de comparación por defecto :ref:`default_function<default-function-single-linked>` como referencia para crear su propia función de comparación.

   :param my_list: Lista en la cual se buscará el elemento.
   :type my_list: :ref:`single_linked_list<single-linked-list>`
   :param element: Elemento a buscar.
   :type element: any
   :param cmp_function: Función de comparación.
   :type cmp_function: function

   :returns: Posición del elemento si está presente, ``-1`` en caso contrario.
   :rtype: int

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import single_linked_list as sll

         # Función de comparación por defecto
         cmp_function = sll.default_function

         # Crea una lista vacía
         lista = sll.new_list()
         lista = sll.add_last(lista, 1)
         lista = sll.add_last(lista, 2)
         print(sll.is_present(lista, 2, cmp_function)) # Salida esperada: 1

   :Test Scenarios:
      - **Elemento presente**: Se verifica si un elemento está presente en la lista.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Función de comparación por defecto
            cmp_function = sll.default_function

            # Lista con elementos
            lista = sll.new_list()
            lista = sll.add_last(lista, 1)
            lista = sll.add_last(lista, 2)
            print(sll.is_present(lista, 2, cmp_function))
            # Salida esperada: 1

      - **Elemento no presente**: Se verifica si un elemento no está presente en la lista.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Función de comparación por defecto
            cmp_function = sll.default_function

            # Lista con elementos
            lista = sll.new_list()
            lista = sll.add_last(lista, 1)
            lista = sll.add_last(lista, 2)
            print(sll.is_present(lista, 3, cmp_function))
            # Salida esperada: -1

.. py:function:: change_info(my_list, pos, new_info)

   Cambia la información de un elemento en la posición dada.

   Cambia la información del elemento en la posición ``pos`` por la información ``new_info``.
   Si la posición no es válida, lanza un error :code:`IndexError: list index out of range`.

   :param my_list: Lista en la cual se cambiará la información del elemento.
   :type my_list: :ref:`single_linked_list<single-linked-list>`
   :param pos: Posición del elemento a cambiar.
   :type pos: int
   :param new_info: Nueva información del elemento.
   :type new_info: any

   :returns: Lista con la información del elemento cambiada.
   :rtype: :ref:`single_linked_list<single-linked-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import single_linked_list as sll

         # Crea una lista vacía
         lista = sll.new_list()
         lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
         lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
         print(sll.change_info(lista, 1, {'name': 'Tres', 'number': 3})) 
         # Salida esperada: 
         # {'size': 2, 
         #  'first': {'info': {'name': 'Uno', 'number': 1}, 'next': {'info': {'name': 'Tres', 'number': 3}, 'next': None}}, 
         #  'last': {'info': {'name': 'Tres', 'number': 3}, 'next': None}
         # }

   :Test Scenarios:
      - **Posición inválida**: Se cambia la información de un elemento en una posición inválida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Crea una lista vacía
            lista = sll.new_list()
            print(sll.change_info(lista, 3, {'name': 'Tres', 'number': 3}))
            # Salida esperada: "IndexError: list index out of range"

      - **Posición válida**: Se cambia la información de un elemento en una posición válida.
  
         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Lista con elementos
            lista = sll.new_list()
            lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
            lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
            print(sll.change_info(lista, 1, {'name': 'Tres', 'number': 3}))
            # Salida esperada:
            # {'size': 2,
            #  'first': {'info': {'name': 'Uno', 'number': 1},
            #            'next': {'info': {'name': 'Tres', 'number': 3},
            #                     'next': None
            #                    }
            #           },
            #  'last': {'info': {'name': 'Tres', 'number': 3}, 'next': None}
            # }

.. py:function:: exchange(my_list, pos_1, pos_2)

   Intercambia la posición de dos elementos.

   Intercambia la posición de los elementos en las posiciones ``pos_1`` y ``pos_2``.
   Si alguna de las posiciones no es válida, lanza un error :code:`IndexError: list index out of range`.

   :param my_list: Lista en la cual se intercambiarán los elementos.
   :type my_list: :ref:`single_linked_list<single-linked-list>`
   :param pos_1: Posición del primer elemento a intercambiar.
   :type pos_1: int
   :param pos_2: Posición del segundo elemento a intercambiar.
   :type pos_2: int

   :returns: Lista con los elementos intercambiados.
   :rtype: :ref:`single_linked_list<single-linked-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import single_linked_list as sll

         # Crea una lista vacía
         lista = sll.new_list()
         lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
         lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
         print(sll.exchange(lista, 0, 1)) 
         # Salida esperada: 
         # {'size': 2, 
         #  'first': {'info': {'name': 'Dos', 'number': 2}, 'next': {'info': {'name': 'Uno', 'number': 1}, 'next': None}}, 
         #  'last': {'info': {'name': 'Uno', 'number': 1}, 'next': None}
         # }

   :Test Scenarios:
      - **Posiciones inválidas**: Se intercambia la posición de dos elementos en posiciones inválidas.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Crea una lista vacía
            lista = sll.new_list()
            print(sll.exchange(lista, 3, 4))
            # Salida esperada: "IndexError: list index out of range"

      - **Posiciones válidas**: Se intercambia la posición de dos elementos en posiciones válidas.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Lista con elementos
            lista = sll.new_list()
            lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
            lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
            print(sll.exchange(lista, 0, 1))
            # Salida esperada:
            # {'size': 2,
            #  'first': {'info': {'name': 'Dos', 'number': 2},
            #            'next': {'info': {'name': 'Uno', 'number': 1},
            #                     'next': None
            #                    }
            #           },
            #  'last': {'info': {'name': 'Uno', 'number': 1}, 'next': None}
            # }

.. py:function:: sub_list(my_list, pos, num_elements)

   Retorna una sublista de la lista original.

   Retorna una sublista de la lista original que contiene ``num_elements`` elementos a partir de la posición ``pos``.
   Si la posición no es válida, lanza un error :code:`IndexError: list index out of range`.

   :param my_list: Lista de la cual se obtendrá la sublista.
   :type my_list: :ref:`single_linked_list<single-linked-list>`
   :param pos: Posición inicial de la sublista.
   :type pos: int
   :param num_elements: Número de elementos de la sublista.
   :type num_elements: int

   :returns: Sublista de la lista original.
   :rtype: :ref:`single_linked_list<single-linked-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import single_linked_list as sll

         # Crea una lista vacía
         lista = sll.new_list()
         lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
         lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
         lista = sll.add_last(lista, {'name': 'Tres', 'number': 3})
         print(sll.sub_list(lista, 1, 2)) 
         # Salida esperada: 
         # {'size': 2, 
         #  'first': {'info': {'name': 'Dos', 'number': 2}, 'next': {'info': {'name': 'Tres', 'number': 3}, 'next': None}}, 
         #  'last': {'info': {'name': 'Tres', 'number': 3}, 'next': None}
         # }

   :Test Scenarios:
      - **Posición inválida**: Se obtiene una sublista de una lista en una posición inválida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Crea una lista vacía
            lista = sll.new_list()
            print(sll.sub_list(lista, 3, 2))
            # Salida esperada: "IndexError: list index out of range"

      - **Posición válida**: Se obtiene una sublista de una lista en una posición válida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import single_linked_list as sll

            # Lista con elementos
            lista = sll.new_list()
            lista = sll.add_last(lista, {'name': 'Uno', 'number': 1})
            lista = sll.add_last(lista, {'name': 'Dos', 'number': 2})
            lista = sll.add_last(lista, {'name': 'Tres', 'number': 3})
            print(sll.sub_list(lista, 1, 2))
            # Salida esperada:
            # {'size': 2,
            #  'first': {'info': {'name': 'Dos', 'number': 2},
            #            'next': {'info': {'name': 'Tres', 'number': 3},
            #                     'next': None
            #                    }
            #           },
            #  'last': {'info': {'name': 'Tres', 'number': 3}, 'next': None}
            # }

Ordenamientos
#################################################

.. admonition:: Importante
   :class: error

   Las funciones de ordenamientos presentadas a continuación deberán ser implementadas tanto en la implementación de arreglos como en la de listas enlazadas simples.
   
   Por motivos prácticos, los ejemplos y pruebas de estas funciones se realizarán en la implementación de :ref:`array_list<array-list>`

.. _default-sort-criteria:

.. py:function:: default_sort_criteria(element_1, element_2)

   Función de comparación por defecto para ordenar elementos.

   Compara dos elementos y retorna ``True`` si el primer elemento es menor que el segundo y ``False`` en caso contrario.

   .. admonition:: Importante
      :class: note

      Una ``sort_criteria`` es una función de comparación que recibe dos elementos y retorna un valor booleano.
      Use esta función como referencia para crear su propia función de comparación donde dependiendo de los condicionales se de un orden **ascendente** o **descendente**. Por ejemplo, si se desea ordenar de forma ascendente, se debe retornar ``True`` si el primer elemento es menor que el segundo y ``False`` en caso contrario, como se ve en los ejemplos presentados a continuación.

   :param element_1: Primer elemento a comparar.
   :type element_1: any
   :param element_2: Segundo elemento a comparar.
   :type element_2: any

   :returns: ``True`` si el primer elemento es menor que el segundo, ``False`` en caso contrario.
   :rtype: bool

   :Code example:

      - **Comparación de números**:

         .. code-block:: python
            :emphasize-lines: 4

            def default_sort_criteria(element_1, element_2):
  
               is_sorted = False
               if element_1 < element_2:
                  is_sorted = True
               return is_sorted

      - **Comparación de diccionarios**:

         .. code-block:: python
            :emphasize-lines: 4

            def default_sort_criteria(element_1, element_2):
  
               is_sorted = False
               if float(element_1["average_rating"]) < float(element2["average_rating"]):
                  is_sorted = True
               return is_sorted



.. py:function:: selection_sort(my_list, sort_crit)

   Ordena una lista utilizando el algoritmo de ordenamiento **Selecion Sort**.

   Se recorre la lista y se selecciona el elemento más pequeño y se intercambia con el primer elemento. 
   Luego se selecciona el segundo elemento más pequeño y se intercambia con el segundo elemento, y así sucesivamente.

   .. admonition:: Ayuda
         :class: note

         Una ``sort_crit`` es una función de comparación que recibe dos elementos y retorna un valor booleano.
         Use la función de criterio de ordenamiento por defecto :ref:`default_sort_criteria<default-sort-criteria>` como referencia para crear su propio criterio de ordenamiento.


   .. admonition:: Nota
         :class: warning

         Dependiendo de la función de comparación, se ordena la lista de forma ascendente o descendente.

   :param my_list: Lista a ordenar.
   :type my_list: :ref:`array_list<array-list>` o :ref:`single_linked_list<single-linked-list>`
   :param sort_crit: Función de comparación.
   :type sort_crit: function

   :returns: Lista ordenada.
   :rtype: :ref:`array_list<array-list>` o :ref:`single_linked_list<single-linked-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Función de comparación por defecto
         sort_crit = al.default_sort_criteria

         # Crea una lista vacía
         lista = al.new_list()
         lista = al.add_last(lista, 3)
         lista = al.add_last(lista, 1)
         lista = al.add_last(lista, 2)
         print(al.selection_sort(lista, sort_crit))
         # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

   :Test Scenarios:

      - **Lista desordenada**: Se ordena una lista desordenada.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Función de comparación por defecto
            sort_crit = al.default_sort_criteria

            # Lista desordenada
            lista = al.new_list()
            lista = al.add_last(lista, 3)
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)
            print(al.selection_sort(lista, sort_crit))
            # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

      - **Lista ordenada**: Se ordena una lista ordenada.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Función de comparación por defecto
            sort_crit = al.default_sort_criteria

            # Lista ordenada
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)
            lista = al.add_last(lista, 3)
            print(al.selection_sort(lista, sort_crit))
            # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

      - **Lista invertida**: Se ordena una lista invertida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Función de comparación por defecto
            sort_crit = al.default_sort_criteria

            # Lista invertida
            lista = al.new_list()
            lista = al.add_last(lista, 3)
            lista = al.add_last(lista, 2)
            lista = al.add_last(lista, 1)
            print(al.selection_sort(lista, sort_crit))
            # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

.. py:function:: insertion_sort(my_list, sort_crit)

   Ordena una lista utilizando el algoritmo de ordenamiento **Insertion Sort**.

   Se recorre la lista y se inserta cada elemento en su posición correcta.Se repite este proceso hasta que todos los elementos estén ordenados.

   .. admonition:: Importante
         :class: note

         Una ``sort_crit`` es una función de comparación que recibe dos elementos y retorna un valor booleano.
         Use la función de criterio de ordenamiento por defecto :ref:`default_sort_criteria<default-sort-criteria>` como referencia para crear su propio criterio de ordenamiento.

   .. admonition:: Nota
         :class: warning

         Dependiendo de la función de comparación, se ordena la lista de forma ascendente o descendente.

   :param my_list: Lista a ordenar.
   :type my_list: :ref:`array_list<array-list>` o :ref:`single_linked_list<single-linked-list>`
   :param sort_crit: Función de comparación.
   :type sort_crit: function

   :returns: Lista ordenada.
   :rtype: :ref:`array_list<array-list>` o :ref:`single_linked_list<single-linked-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Función de comparación por defecto
         sort_crit = al.default_sort_criteria

         # Crea una lista vacía
         lista = al.new_list()
         lista = al.add_last(lista, 3)
         lista = al.add_last(lista, 1)
         lista = al.add_last(lista, 2)
         print(al.insertion_sort(lista, sort_crit))
         # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

   :Test Scenarios:

      - **Lista desordenada**: Se ordena una lista desordenada.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Función de comparación por defecto
            sort_crit = al.default_sort_criteria

            # Lista desordenada
            lista = al.new_list()
            lista = al.add_last(lista, 3)
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)
            print(al.insertion_sort(lista, sort_crit))
            # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

      - **Lista ordenada**: Se ordena una lista ordenada.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Función de comparación por defecto
            sort_crit = al.default_sort_criteria

            # Lista ordenada
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)
            lista = al.add_last(lista, 3)
            print(al.insertion_sort(lista, sort_crit))
            # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

      - **Lista invertida**: Se ordena una lista invertida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Función de comparación por defecto
            sort_crit = al.default_sort_criteria

            # Lista invertida
            lista = al.new_list()
            lista = al.add_last(lista, 3)
            lista = al.add_last(lista, 2)
            lista = al.add_last(lista, 1)
            print(al.insertion_sort(lista, sort_crit))
            # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

.. py:function:: shell_sort(my_list, sort_crit)

   Ordena una lista utilizando el algoritmo de ordenamiento **Shell Sort**.

   Se recorre la lista y se ordena los elementos con un gap determinado.
   Se repite el proceso con un gap menor hasta que la lista esté ordenada.

   Si la lista es vacía o tiene un solo elemento, se retorna la lista original.

   .. admonition:: Importante
         :class: note

         Una ``sort_crit`` es una función de comparación que recibe dos elementos y retorna un valor booleano.
         Use la función de criterio de ordenamiento por defecto :ref:`default_sort_criteria<default-sort-criteria>` como referencia para crear su propio criterio de ordenamiento.

   .. admonition:: Nota
         :class: warning

         Dependiendo de la función de comparación, se ordena la lista de forma ascendente o descendente.

   :param my_list: Lista a ordenar.
   :type my_list: :ref:`array_list<array-list>` o :ref:`single_linked_list<single-linked-list>`
   :param sort_crit: Función de comparación.
   :type sort_crit: function

   :returns: Lista ordenada.
   :rtype: :ref:`array_list<array-list>` o :ref:`single_linked_list<single-linked-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Función de comparación por defecto
         sort_crit = al.default_sort_criteria

         # Crea una lista vacía
         lista = al.new_list()
         lista = al.add_last(lista, 3)
         lista = al.add_last(lista, 1)
         lista = al.add_last(lista, 2)
         print(al.shell_sort(lista, sort_crit))
         # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

   :Test Scenarios:

      - **Lista desordenada**: Se ordena una lista desordenada.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Función de comparación por defecto
            sort_crit = al.default_sort_criteria

            # Lista desordenada
            lista = al.new_list()
            lista = al.add_last(lista, 3)
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)

            print(al.shell_sort(lista, sort_crit))
            # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

      - **Lista ordenada**: Se ordena una lista ordenada.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Función de comparación por defecto
            sort_crit = al.default_sort_criteria

            # Lista ordenada
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)
            lista = al.add_last(lista, 3)

            print(al.shell_sort(lista, sort_crit))
            # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

      - **Lista invertida**: Se ordena una lista invertida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Función de comparación por defecto
            sort_crit = al.default_sort_criteria

            # Lista invertida
            lista = al.new_list()
            lista = al.add_last(lista, 3)
            lista = al.add_last(lista, 2)
            lista = al.add_last(lista, 1)

            print(al.shell_sort(lista, sort_crit))
            # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

.. py:function:: merge_sort(my_list, sort_crit)

   Ordena una lista utilizando el algoritmo recursivo de ordenamiento **Merge Sort**.

   Se divide la lista en dos partes iguales* y se ordenan de forma recursiva.
   Luego se mezclan las dos partes ordenadas.

   Si la lista es vacía o tiene un solo elemento, se retorna la lista original.

   .. admonition:: Importante
         :class: note

         Una ``sort_crit`` es una función de comparación que recibe dos elementos y retorna un valor booleano.
         Use la función de criterio de ordenamiento por defecto :ref:`default_sort_criteria<default-sort-criteria>` como referencia para crear su propio criterio de ordenamiento.

   .. admonition:: Nota
         :class: warning

         Dependiendo de la función de comparación, se ordena la lista de forma ascendente o descendente.

   :param my_list: Lista a ordenar.
   :type my_list: :ref:`array_list<array-list>` o :ref:`single_linked_list<single-linked-list>`
   :param sort_crit: Función de comparación.
   :type sort_crit: function

   :returns: Lista ordenada.
   :rtype: :ref:`array_list<array-list>` o :ref:`single_linked_list<single-linked-list>`

   :Example:
      .. code-block:: python

         # App/logic.py
         from DataStructures.List import array_list as al

         # Función de comparación por defecto
         sort_crit = al.default_sort_criteria

         # Crea una lista vacía
         lista = al.new_list()
         lista = al.add_last(lista, 3)
         lista = al.add_last(lista, 1)
         lista = al.add_last(lista, 2)
         print(al.merge_sort(lista, sort_crit))
         # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

   :Test Scenarios:

      - **Lista desordenada**: Se ordena una lista desordenada.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Función de comparación por defecto
            sort_crit = al.default_sort_criteria

            # Lista desordenada
            lista = al.new_list()
            lista = al.add_last(lista, 3)
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)

            print(al.merge_sort(lista, sort_crit))
            # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

      - **Lista ordenada**: Se ordena una lista ordenada.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Función de comparación por defecto
            sort_crit = al.default_sort_criteria

            # Lista ordenada
            lista = al.new_list()
            lista = al.add_last(lista, 1)
            lista = al.add_last(lista, 2)
            lista = al.add_last(lista, 3)

            print(al.merge_sort(lista, sort_crit))
            # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

      - **Lista invertida**: Se ordena una lista invertida.

         .. code-block:: python

            # App/logic.py
            from DataStructures.List import array_list as al

            # Función de comparación por defecto
            sort_crit = al.default_sort_criteria

            # Lista invertida
            lista = al.new_list()
            lista = al.add_last(lista, 3)
            lista = al.add_last(lista, 2)
            lista = al.add_last(lista, 1)

            print(al.merge_sort(lista, sort_crit))
            # Salida esperada: {'size': 3, 'elements': [1, 2, 3]}

.. py:function:: quick_sort(my_list, sort_crit)

   Ordena una lista utilizando el algoritmo recursivo de ordenamiento **Quick Sort**.

   Se selecciona un elemento como **pivote** y se colocan los elementos menores a la izquierda y los mayores a la derecha de este elemento **pivote**.

   Si la lista es vacía o tiene un solo elemento, se retorna la lista original.

   .. admonition:: Importante
      :class: note

      Una ``sort_crit`` es una función de comparación que recibe dos elementos y retorna un valor booleano.
      Use la función de criterio de ordenamiento por defecto :ref:`default_sort_criteria<default-sort-criteria>` como referencia para crear su propio criterio de ordenamiento.

   .. admonition:: Nota
      :class: warning

      Dependiendo de la función de comparación, se ordena la lista de forma ascendente o descendente.

   :param my_list: Lista a ordenar.
   :type my_list: :ref:`array_list<array-list>` o :ref:`single_linked_list<single-linked-list>`
   :param sort_crit: Función de comparación.
   :type sort_crit: function

   :returns: Lista ordenada.
   :rtype: :ref:`array_list<array-list>` o :ref:`single_linked_list<single-linked-list>`
